var documenterSearchIndex = {"docs":
[{"location":"man/evaluators/#Evaluators","page":"Evaluators","title":"Evaluators","text":"","category":"section"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"In Argos.jl, the evaluators are the final layer of the structure. They take as input a given ExaPF.AbstractFormulation and implement the callbacks for the optimization solvers.","category":"page"},{"location":"man/evaluators/#Overview-of-the-AbstractNLPEvaluator","page":"Evaluators","title":"Overview of the AbstractNLPEvaluator","text":"","category":"section"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"An Argos.AbstractNLPEvaluator implements an optimization problem associated with an underlying ExaPF.AbstractFormulation:","category":"page"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"beginaligned\nmin_u in mathbbR^n               f(u)     \ntextsubject to quad  g(u) = 0 \n                         h(u) leq 0\nendaligned","category":"page"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"with f mathbbR^n to mathbbR the objective function, g mathbbR^n to mathbbR^m_E non-linear equality constraints and h mathbbR^n to mathbbR^m_I non-linear inequality constraints.","category":"page"},{"location":"man/evaluators/#Callbacks","page":"Evaluators","title":"Callbacks","text":"","category":"section"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"Most non-linear optimization algorithms rely on callbacks to pass information about the structure of the problem to the optimizer. In Argos, the implementation of the evaluators allows to have a proper splitting between the model (formulated in the ExaPF.AbstractFormulation layer) and the optimization algorithms. By design, the implementation of an Argos.AbstractNLPEvaluator shares a similar spirit with the implementations introduced in other packages, as","category":"page"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"MathOptInterface.jl's AbstractNLPEvaluator\nNLPModels' AbstractNLPModel","category":"page"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"Internally, the evaluator caches all the information needed to evaluate the callbacks (e.g. the polar representation of the problem, with voltage magnitudes and angles). This cache allows to reduce the number of memory allocations to its minimum. Once a new variable u passed to the evaluator a function Argos.update! is being called to update the cache, according to the model specified in the underlying ExaPF.AbstractFormulation. Denoting by nlp an instance of AbstractNLPEvaluator, the cache is updated via","category":"page"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"julia> Argos.update!(nlp, u)","category":"page"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"Once the internal structure updated, we are ready to call the different callbacks, in every order. For instance, computing the objective, the gradient and the constraints amounts to","category":"page"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"# Objective\njulia> obj = Argos.objective(nlp, u)\n# Gradient\njulia> g = zeros(n_variables(nlp))\njulia> Argos.gradient!(nlp, g, u)\n# Constraints\njulia> cons = zeros(n_constraints(nlp))\njulia> Argos.constraint!(nlp, cons, u)\n","category":"page"},{"location":"man/evaluators/#A-journey-to-the-reduced-space-with-the-ReducedSpaceEvaluator","page":"Evaluators","title":"A journey to the reduced space with the ReducedSpaceEvaluator","text":"","category":"section"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"When we aim at optimizing the problem directly in the powerflow manifold, the Argos.ReducedSpaceEvaluator is our workhorse. We recall that the powerflow manifold is defined implicitly by the powerflow equations:","category":"page"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"    g(x(u) u) = 0","category":"page"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"By design, the Argos.ReducedSpaceEvaluator works in the reduced space (x(u) u). Hence, the reduced optimization problem writes out","category":"page"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"beginaligned\nmin_u in mathbbR^n   f(x(u) u) \ntextsubject to quad       h(x(u) u) leq 0\nendaligned","category":"page"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"This formulation comes with two advantages:","category":"page"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"if the dimension of the state is large, the reduced problem has a lower dimension.\nthe powerflow equality constraints g(x u) = 0 disappear in the reduced problem.","category":"page"},{"location":"man/evaluators/#Playing-with-the-ReducedSpaceEvaluator","page":"Evaluators","title":"Playing with the ReducedSpaceEvaluator","text":"","category":"section"},{"location":"man/evaluators/#Constructor","page":"Evaluators","title":"Constructor","text":"","category":"section"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"To create a Argos.ReducedSpaceEvaluator, we just need a polar formulation polar::PolarForm:","category":"page"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"julia> nlp = Argos.ReducedSpaceEvaluator(polar)\n","category":"page"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"or we could alternatively instantiate the evaluator directly from a MATPOWER (or PSSE) instance:","category":"page"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"julia> datafile = \"case9.m\"\njulia> nlp = Argos.ReducedSpaceEvaluator(datafile)\nA ReducedSpaceEvaluator object\n    * device: KernelAbstractions.CPU()\n    * #vars: 5\n    * #cons: 10\n    * constraints:\n        - voltage_magnitude_constraints\n        - active_power_constraints\n        - reactive_power_constraints\n    * linear solver: ExaPF.LinearSolvers.DirectSolver()\n","category":"page"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"Let's describe the output of the last command.","category":"page"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"device: KernelAbstractions.CPU(): the evaluator is instantiated on the CPU ;\n#vars: 5: it has 5 optimization variables ;\n#cons: 10: and 10 inequality constraints ;\nconstraints: by default, nlp comes with three inequality constraints: voltage_magnitude_constraints (specifying the bounds x_L leq x(u) leq x_U on the state x), active_power_constraints and reactive_power_constraints (bounding the active and reactive power of the generators) ;\nlinear solver: ExaPF.LinearSolvers.DirectSolver: to solve the linear systems, the evaluator uses a direct linear algebra solver.","category":"page"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"Of course, these settings are only specified by default. The user is free to choose the parameters she wants. For instance,","category":"page"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"We could remove all constraints by passing an empty array of constraints to the evaluator:\njulia> constraints = Function[]\njulia> nlp = Argos.ReducedSpaceEvaluator(datafile; constraints=constraints)\nWe could load the evaluator on the GPU simply by changing the device option:\njulia> nlp = Argos.ReducedSpaceEvaluator(datafile; device=CUDADevice())","category":"page"},{"location":"man/evaluators/#Caching","page":"Evaluators","title":"Caching","text":"","category":"section"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"To juggle between the mathematical description (characterized by a state x and a control u) and the physical description (characterized by the voltage and power injection at each bus), the evaluator nlp stores internally a cache nlp.buffer, with type ExaPF.AbstractNetworkBuffer.","category":"page"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"julia> buffer = get(nlp, ExaPF.PhysicalState())","category":"page"},{"location":"man/evaluators/#Evaluation-of-the-callbacks","page":"Evaluators","title":"Evaluation of the callbacks","text":"","category":"section"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"Now that we have a nlp evaluator available, we can embed it in any optimization routine. For instance, suppose we have a new control uk available. First, we need to find the corresponding state xk, such that g(x_k u_k) = 0. In the evaluator's API, this sums up to:","category":"page"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"Argos.update!(nlp, uk)\n","category":"page"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"The function update! will","category":"page"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"Feed the physical description nlp.buffer with the values stored in the new control uk.\nSolve the powerflow equations corresponding to the formulation specified in form. This operation updates the cache nlp.buffer inplace.","category":"page"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"Once the function update! called (and only after that), we can evaluate all the different callbacks, independently of one other.","category":"page"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"Objective\njulia> cost = Argos.objective(nlp, uk)\nObjective's gradient\njulia> g = zeros(n_variables(nlp))\njulia> Argos.gradient!(nlp, g, uk)\nConstraints\n# Evaluate constraints\njulia> cons = zeros(n_constraints(nlp))\njulia> Argos.constraint!(nlp, cons, uk)\nConstraints' Jacobian\n## Evaluate Jacobian\njulia> Argos.jacobian!(nlp, jac, uk)\nConstraints' Jacobian-vector product:\n## Evaluate Jacobian-vector product\njulia> v = zeros(n_variables(nlp))\njulia> jv = zeros(n_constraints(nlp))\njulia> Argos.jprod!(nlp, jv, uk, v)\nConstraints' transpose Jacobian-vector product\n## Evaluate transpose Jacobian-vector product\njulia> v = zeros(n_constraints(nlp))\njulia> jv = zeros(n_variables(nlp))\njulia> Argos.jtprod!(nlp, jv, uk, v)\nHessian-vector product:\n## Evaluate transpose Jacobian-vector product\njulia> v = zeros(n_variables(nlp))\njulia> hv = zeros(n_variables(nlp))\njulia> Argos.hessprod!(nlp, hv, uk, v)\nHessian:\n## Evaluate transpose Jacobian-vector product\njulia> H = zeros(n_variables(nlp), n_variables(nlp))\njulia> Argos.hessprod!(nlp, H, uk)","category":"page"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"note: Note\nOnce the powerflow equations solved in a update! call, the solution x_k is stored implicitly in nlp.buffer. These values will be used as a starting point for the next resolution of powerflow equations.","category":"page"},{"location":"man/evaluators/#Passing-the-problem-to-an-optimization-solver-with-MathOptInterface","page":"Evaluators","title":"Passing the problem to an optimization solver with MathOptInterface","text":"","category":"section"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"Argos.jl provides a utility to pass the non-linear structure specified by a Argos.AbstractNLPEvaluator to a MathOptInterface (MOI) optimization problem. That allows to solve the corresponding optimal power flow problem using any non-linear optimization solver compatible with MOI.","category":"page"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"For instance, we can solve the reduced problem specified in nlp with Ipopt. In a few lines of code:","category":"page"},{"location":"man/evaluators/","page":"Evaluators","title":"Evaluators","text":"using Ipopt\noptimizer = Ipopt.Optimizer()\nMOI.set(optimizer, MOI.RawParameter(\"print_level\"), 5)\nMOI.set(optimizer, MOI.RawParameter(\"limited_memory_max_history\"), 50)\nMOI.set(optimizer, MOI.RawParameter(\"hessian_approximation\"), \"limited-memory\")\nsolution = Argos.optimize!(optimizer, nlp)\nMOI.empty!(optimizer)\n","category":"page"},{"location":"#ExaPF","page":"Home","title":"ExaPF","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Argos.jl is a package extending ExaPF.jl for the resolution of large-scale optimal power flow (OPF) problems on exascale architectures.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Argos.jl implements a generic interface for the various callbacks needed by nonlinear optimization solvers. The callbacks are defined inside Evaluators structure, each Evaluator having its particular use-case. Among these evaluators, the [ReducedSpaceEvaluator](@ref) uses the fast power flow solver implemented in ExaPF.jl to run the optimization directly in the reduced space induced by the power flow equations.","category":"page"},{"location":"#Table-of-contents","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"man/evaluators.md\",\n]\nDepth = 1","category":"page"},{"location":"#Library","page":"Home","title":"Library","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"lib/evaluators.md\",\n]\nDepth = 1","category":"page"},{"location":"#Funding","page":"Home","title":"Funding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This research was supported by the Exascale Computing Project (17-SC-20-SC), a joint project of the U.S. Department of Energy’s Office of Science and National Nuclear Security Administration, responsible for delivering a capable exascale ecosystem, including software, applications, and hardware technology, to support the nation’s exascale computing imperative.","category":"page"},{"location":"lib/evaluators/","page":"Evaluators","title":"Evaluators","text":"CurrentModule = Argos","category":"page"},{"location":"lib/evaluators/#Evaluators","page":"Evaluators","title":"Evaluators","text":"","category":"section"},{"location":"lib/evaluators/#Description","page":"Evaluators","title":"Description","text":"","category":"section"},{"location":"lib/evaluators/","page":"Evaluators","title":"Evaluators","text":"AbstractNLPEvaluator","category":"page"},{"location":"lib/evaluators/#Argos.AbstractNLPEvaluator","page":"Evaluators","title":"Argos.AbstractNLPEvaluator","text":"AbstractNLPEvaluator\n\nAbstractNLPEvaluator implements the bridge between the problem formulation (see ExaPF.AbstractFormulation) and the optimization solver. Once the problem formulation bridged, the evaluator allows to evaluate:\n\nthe objective;\nthe gradient of the objective;\nthe constraints;\nthe Jacobian of the constraints;\nthe Jacobian-vector and transpose-Jacobian vector products of the constraints;\nthe Hessian of the objective;\nthe Hessian of the Lagrangian.\n\n\n\n\n\n","category":"type"},{"location":"lib/evaluators/#API-Reference","page":"Evaluators","title":"API Reference","text":"","category":"section"},{"location":"lib/evaluators/#Optimization","page":"Evaluators","title":"Optimization","text":"","category":"section"},{"location":"lib/evaluators/","page":"Evaluators","title":"Evaluators","text":"optimize!","category":"page"},{"location":"lib/evaluators/#Argos.optimize!","page":"Evaluators","title":"Argos.optimize!","text":"optimize!(optimizer, nlp::AbstractNLPEvaluator, x0)\n\nUse optimization routine implemented in optimizer to optimize the optimal power flow problem specified in the evaluator nlp. Initial point is specified by x0.\n\nReturn the solution as a named tuple, with fields\n\nstatus::MOI.TerminationStatus: Solver's termination status, as specified by MOI\nminimum::Float64: final objective\nminimizer::AbstractVector: final solution vector, with same ordering as the Variables specified in nlp.\n\noptimize!(optimizer, nlp::AbstractNLPEvaluator)\n\nWrap previous optimize! function and pass as initial guess x0 the initial value specified when calling initial(nlp).\n\nExamples\n\nnlp = ExaPF.ReducedSpaceEvaluator(datafile)\noptimizer = Ipopt.Optimizer()\nsolution = ExaPF.optimize!(optimizer, nlp)\n\n\nNotes\n\nBy default, the optimization routine solves a minimization problem.\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators/#Attributes","page":"Evaluators","title":"Attributes","text":"","category":"section"},{"location":"lib/evaluators/","page":"Evaluators","title":"Evaluators","text":"Variables\nConstraints\nn_variables\nn_constraints\nconstraints_type\n","category":"page"},{"location":"lib/evaluators/#Argos.Variables","page":"Evaluators","title":"Argos.Variables","text":"Variables <: AbstractNLPAttribute end\n\nAttribute corresponding to the optimization variables attached to a given AbstractNLPEvaluator.\n\n\n\n\n\n","category":"type"},{"location":"lib/evaluators/#Argos.Constraints","page":"Evaluators","title":"Argos.Constraints","text":"Constraints <: AbstractNLPAttribute end\n\nAttribute corresponding to the constraints  attached to a given AbstractNLPEvaluator.\n\n\n\n\n\n","category":"type"},{"location":"lib/evaluators/#Argos.n_variables","page":"Evaluators","title":"Argos.n_variables","text":"n_variables(nlp::AbstractNLPEvaluator)\n\nGet the number of variables in the problem.\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators/#Argos.n_constraints","page":"Evaluators","title":"Argos.n_constraints","text":"n_constraints(nlp::AbstractNLPEvaluator)\n\nGet the number of constraints in the problem.\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators/#Argos.constraints_type","page":"Evaluators","title":"Argos.constraints_type","text":"constraints_type(nlp::AbstractNLPEvaluator)\n\nReturn the type of the non-linear constraints of the evaluator nlp, as a Symbol. Result could be :inequality if problem has only inequality constraints, :equality if problem has only equality constraints, or :mixed if problem has both types of constraints.\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators/#Utilities","page":"Evaluators","title":"Utilities","text":"","category":"section"},{"location":"lib/evaluators/","page":"Evaluators","title":"Evaluators","text":"reset!\nprimal_infeasibility\nprimal_infeasibility!","category":"page"},{"location":"lib/evaluators/#Argos.reset!","page":"Evaluators","title":"Argos.reset!","text":"reset!(nlp::AbstractNLPEvaluator)\n\nReset evaluator nlp to default configuration.\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators/#Callbacks","page":"Evaluators","title":"Callbacks","text":"","category":"section"},{"location":"lib/evaluators/#Objective","page":"Evaluators","title":"Objective","text":"","category":"section"},{"location":"lib/evaluators/","page":"Evaluators","title":"Evaluators","text":"gradient!\nhessprod!\nhessian!\n","category":"page"},{"location":"lib/evaluators/#Argos.gradient!","page":"Evaluators","title":"Argos.gradient!","text":"gradient!(nlp::AbstractNLPEvaluator, g, u)\n\nEvaluate the gradient of the objective, at given variable u. Store the result inplace in the vector g.\n\nNote\n\nThe vector g should have the same dimension as u.\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators/#Argos.hessprod!","page":"Evaluators","title":"Argos.hessprod!","text":"hessprod!(nlp::AbstractNLPEvaluator, hessvec, u, v)\n\nEvaluate the Hessian-vector product ∇²f(u) * v of the objective evaluated at variable u. Store the result inplace, in the vector hessvec.\n\nNote\n\nThe vector hessprod should have the same length as u.\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators/#Argos.hessian!","page":"Evaluators","title":"Argos.hessian!","text":"hessian!(nlp::AbstractNLPEvaluator, H, u)\n\nEvaluate the Hessian ∇²f(u) of the objective function f(u). Store the result inplace, in the n x n dense matrix H.\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators/#Constraints","page":"Evaluators","title":"Constraints","text":"","category":"section"},{"location":"lib/evaluators/","page":"Evaluators","title":"Evaluators","text":"constraint!\njacobian_structure!\njacobian!\njprod!\njtprod!\nojtprod!","category":"page"},{"location":"lib/evaluators/#Argos.constraint!","page":"Evaluators","title":"Argos.constraint!","text":"constraint!(nlp::AbstractNLPEvaluator, cons, u)\n\nEvaluate the constraints of the problem at given variable u. Store the result inplace, in the vector cons.\n\nNote\n\nThe vector cons should have the same dimension as the result returned by n_constraints(nlp).\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators/#Argos.jacobian!","page":"Evaluators","title":"Argos.jacobian!","text":"jacobian!(nlp::AbstractNLPEvaluator, jac::AbstractMatrix, u)\n\nEvaluate the Jacobian of the constraints, at variable u. Store the result inplace, in the m x n dense matrix jac.\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators/#Argos.jprod!","page":"Evaluators","title":"Argos.jprod!","text":"jprod!(nlp::AbstractNLPEvaluator, jv, u, v)\n\nEvaluate the Jacobian-vector product J v of the constraints. The vector jv is modified inplace.\n\nLet (n, m) = n_variables(nlp), n_constraints(nlp).\n\nu is a vector with dimension n\nv is a vector with dimension n\njv is a vector with dimension m\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators/#Argos.jtprod!","page":"Evaluators","title":"Argos.jtprod!","text":"jtprod!(nlp::AbstractNLPEvaluator, jv, u, v)\n\nEvaluate the transpose Jacobian-vector product J^T v of the constraints. The vector jv is modified inplace.\n\nLet (n, m) = n_variables(nlp), n_constraints(nlp).\n\nu is a vector with dimension n\nv is a vector with dimension m\njv is a vector with dimension n\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators/#Argos.ojtprod!","page":"Evaluators","title":"Argos.ojtprod!","text":"ojtprod!(nlp::AbstractNLPEvaluator, jv, u, σ, v)\n\nEvaluate the transpose Jacobian-vector product J' * [σ ; v], with J the Jacobian of the vector [f(x); h(x)]. f(x) is the current objective and h(x) constraints. The vector jv is modified inplace.\n\nLet (n, m) = n_variables(nlp), n_constraints(nlp).\n\njv is a vector with dimension n\nu is a vector with dimension n\nσ is a scalar\nv is a vector with dimension m\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators/#Second-order","page":"Evaluators","title":"Second-order","text":"","category":"section"},{"location":"lib/evaluators/","page":"Evaluators","title":"Evaluators","text":"hessian_lagrangian_penalty_prod!\n","category":"page"},{"location":"lib/evaluators/#Argos.hessian_lagrangian_penalty_prod!","page":"Evaluators","title":"Argos.hessian_lagrangian_penalty_prod!","text":"hessian_lagrangian_penalty_prod!(nlp::AbstractNLPEvaluator, hessvec, u, y, σ, d, v)\n\nEvaluate the Hessian-vector product of the Augmented Lagrangian function L(u y) = f(u) + sum_i y_i c_i(u) + frac12 d_i c_i(u)^2 with a vector v:\n\n²L(u y)  v  = σ ²f(u)  v + sum_i (y_i + d_i) ²c_i(u)  v + sum_i d_i c_i(u)^T c_i(u)\n\nStore the result inplace, in the vector hessvec.\n\nArguments\n\nhessvec is a AbstractVector with dimension n, which is modified inplace.\nu is a AbstractVector with dimension n, storing the current variable.\ny is a AbstractVector with dimension n, storing the current constraints' multipliers\nσ is a scalar\nv is a vector with dimension n.\nd is a vector with dimension m.\n\n\n\n\n\n","category":"function"},{"location":"lib/evaluators/#ReducedSpaceEvaluator","page":"Evaluators","title":"ReducedSpaceEvaluator","text":"","category":"section"},{"location":"lib/evaluators/","page":"Evaluators","title":"Evaluators","text":"When working in the reduced space, we could use the corresponding ReducedSpaceEvaluator:","category":"page"},{"location":"lib/evaluators/","page":"Evaluators","title":"Evaluators","text":"ReducedSpaceEvaluator","category":"page"},{"location":"lib/evaluators/#Argos.ReducedSpaceEvaluator","page":"Evaluators","title":"Argos.ReducedSpaceEvaluator","text":"ReducedSpaceEvaluator{T, VI, VT, MT, Jacx, Jacu, JacCons, Hess} <: AbstractNLPEvaluator\n\nReduced-space evaluator projecting the optimization problem into the powerflow manifold defined by the nonlinear equation g(x u) = 0. The state x is defined implicitly, as a function of the control u. Hence, the powerflow equation is implicitly satisfied when we are using this evaluator.\n\nOnce a new point u is passed to the evaluator, the user needs to call the method update! to find the corresponding state x(u) satisfying the balance equation g(x(u) u) = 0.\n\nTaking as input an ExaPF.PolarForm structure, the reduced evaluator builds the bounds corresponding to the control u, The reduced evaluator could be instantiated on the host memory, or on a specific device (currently, only CUDA is supported).\n\nExamples\n\njulia> datafile = \"case9.m\"  # specify a path to a MATPOWER instance\njulia> nlp = ReducedSpaceEvaluator(datafile)\nA ReducedSpaceEvaluator object\n    * device: KernelAbstractions.CPU()\n    * #vars: 5\n    * #cons: 10\n    * constraints:\n        - voltage_magnitude_constraints\n        - active_power_constraints\n        - reactive_power_constraints\n    * linear solver: ExaPF.LinearSolvers.DirectSolver()\n\nIf a GPU is available, we could instantiate nlp as\n\njulia> nlp_gpu = ReducedSpaceEvaluator(datafile; device=CUDADevice())\nA ReducedSpaceEvaluator object\n    * device: KernelAbstractions.CUDADevice()\n    * #vars: 5\n    * #cons: 10\n    * constraints:\n        - voltage_magnitude_constraints\n        - active_power_constraints\n        - reactive_power_constraints\n    * linear solver: ExaPF.LinearSolvers.DirectSolver()\n\n\nNote\n\nMathematically, we set apart the state x from the control u, and use a third variable y –- the by-product –- to denote the remaining values of the network. In the implementation of ReducedSpaceEvaluator, we only deal with a control u and an attribute buffer, storing all the physical values needed to describe the network. The attribute buffer stores the values of the control u, the state x and the by-product y. Each time we are calling the method update!, the values of the control are copied into the buffer.\n\n\n\n\n\n","category":"type"},{"location":"lib/evaluators/#SlackEvaluator","page":"Evaluators","title":"SlackEvaluator","text":"","category":"section"},{"location":"lib/evaluators/","page":"Evaluators","title":"Evaluators","text":"SlackEvaluator","category":"page"},{"location":"lib/evaluators/#Argos.SlackEvaluator","page":"Evaluators","title":"Argos.SlackEvaluator","text":"SlackEvaluator{Evaluator<:AbstractNLPEvaluator, T, VT} <: AbstractNLPEvaluator\n\nReformulate a problem with inequality constraints as an equality constrained problem, by introducing a set of slack variables.\n\nDescription\n\nA SlackEvaluator takes as input an original AbstractNLPEvaluator, subject to inequality constraints\n\nbeginaligned\n       min_u in mathbbR^n quad  f(u)\nmathrmst quad  h^  h(u)  h^\n                     u^   u    u^\nendaligned\n\nThe SlackEvaluator instance rewrites this problem with inequalities as a new problem comprising only equality constraints, by introducing m slack variables s_1  s_m. The new problem writes out\n\nbeginaligned\n       min_u in mathbbR^n s in mathbbR^m quad  f(u)\n    mathrmst quad  h(u) - s = 0 \n                     u^   u    u^ \n                     h^   s    h^\nendaligned\n\nAttributes\n\ninner::Evaluator: original evaluator\ns_min::VT: stores lower bounds for slack variables\ns_max::VT: stores upper bounds for slack variables\nnv::Int: number of original variables\nns::Int: number of slack variables\n\n\n\n\n\n","category":"type"},{"location":"lib/evaluators/#AugLagEvaluator","page":"Evaluators","title":"AugLagEvaluator","text":"","category":"section"},{"location":"lib/evaluators/","page":"Evaluators","title":"Evaluators","text":"AugLagEvaluator","category":"page"},{"location":"lib/evaluators/#Argos.AugLagEvaluator","page":"Evaluators","title":"Argos.AugLagEvaluator","text":"AugLagEvaluator{Evaluator<:AbstractNLPEvaluator, T, VT} <: AbstractPenaltyEvaluator\n\nAugmented-Lagrangian evaluator.\n\nDescription\n\nTakes as input any AbstractNLPEvaluator encoding a non-linear problem\n\nbeginaligned\n       min_u quad  f(u)\nmathrmst quad  h^  h(u)  h^\n                     u^   u    u^\nendaligned\n\nand return a new evaluator reformulating the original problem by moving the m constraints h^  h(u)  h^ into the objective using a set of penalties ϕ_1  ϕ_m and multiplier estimates λ_1  λ_m:\n\nbeginaligned\n    min_u quad  f(u) + sum_i=1^m ϕ_i(h_i λ_i)   \nmathrmst quad   u^   u     u^\nendaligned\n\nThis evaluator considers explicitly the inequality constraints, without reformulating them by introducing slack variables. Each penalty ϕ_i is defined as\n\nϕ_i(h_i λ_i) = λ_i^ φ_i(h_i) + frac rho2  φ_i(h_i) _2^2\n\nwith φ_i a function to compute the current infeasibility\n\nφ_i(h_i λ_i) = max0  λ_i + ρ (h_i - h_i^)    + min0  λ_i + ρ (h_i - h_i^)   \n\nAttributes\n\ninner::Evaluator: original problem.\ncons_type: type of the constraints of the original problem (equalities or inequalities).\ncons::VT: a buffer storing the current evaluation of the constraints for the inner evaluator.\nrho::T: current penalty.\nλ::VT: current multiplier.\nscaler::MaxScaler{T,VT}: a scaler to rescale the range of the constraints in the original problem.\n\n\n\n\n\n","category":"type"},{"location":"lib/evaluators/#MOIEvaluator","page":"Evaluators","title":"MOIEvaluator","text":"","category":"section"},{"location":"lib/evaluators/","page":"Evaluators","title":"Evaluators","text":"The bridge to MathOptInterface is encoded by the MOIEvaluator structure:","category":"page"},{"location":"lib/evaluators/","page":"Evaluators","title":"Evaluators","text":"MOIEvaluator","category":"page"},{"location":"lib/evaluators/#Argos.MOIEvaluator","page":"Evaluators","title":"Argos.MOIEvaluator","text":"MOIEvaluator <: MOI.AbstractNLPEvaluator\n\nBridge from a AbstractNLPEvaluator to a MOI.AbstractNLPEvaluator.\n\nAttributes\n\nnlp::AbstractNLPEvaluator: the underlying ExaPF problem.\nhash_x::UInt: hash of the last evaluated variable x\nhas_hess::Bool (default: false): if true, pass a Hessian structure to MOI.\n\n\n\n\n\n","category":"type"},{"location":"lib/evaluators/#ProxALEvaluator","page":"Evaluators","title":"ProxALEvaluator","text":"","category":"section"},{"location":"lib/evaluators/","page":"Evaluators","title":"Evaluators","text":"ProxALEvaluator","category":"page"}]
}
