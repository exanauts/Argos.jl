<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Evaluators · Argos.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Argos.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li class="is-active"><a class="tocitem" href>Evaluators</a><ul class="internal"><li><a class="tocitem" href="#Overview-of-the-AbstractNLPEvaluator"><span>Overview of the AbstractNLPEvaluator</span></a></li><li><a class="tocitem" href="#A-journey-to-the-reduced-space-with-the-ReducedSpaceEvaluator"><span>A journey to the reduced space with the ReducedSpaceEvaluator</span></a></li><li><a class="tocitem" href="#Passing-the-problem-to-an-optimization-solver-with-MathOptInterface"><span>Passing the problem to an optimization solver with MathOptInterface</span></a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/evaluators/">Evaluators</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Evaluators</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Evaluators</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/exanauts/Argos.jl/blob/master/docs/src/man/evaluators.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Evaluators"><a class="docs-heading-anchor" href="#Evaluators">Evaluators</a><a id="Evaluators-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluators" title="Permalink"></a></h1><p>In <code>Argos.jl</code>, the evaluators are the final layer of the structure. They take as input a given <code>ExaPF.AbstractFormulation</code> and implement the callbacks for the optimization solvers.</p><h2 id="Overview-of-the-AbstractNLPEvaluator"><a class="docs-heading-anchor" href="#Overview-of-the-AbstractNLPEvaluator">Overview of the AbstractNLPEvaluator</a><a id="Overview-of-the-AbstractNLPEvaluator-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-of-the-AbstractNLPEvaluator" title="Permalink"></a></h2><p>An <a href="../../lib/evaluators/#Argos.AbstractNLPEvaluator"><code>Argos.AbstractNLPEvaluator</code></a> implements an optimization problem associated with an underlying <code>ExaPF.AbstractFormulation</code>:</p><p class="math-container">\[\begin{aligned}
\min_{u \in \mathbb{R}^n} \;             &amp; f(u)     \\
\text{subject to} \quad &amp; g(u) = 0 \\
                        &amp; h(u) \leq 0.
\end{aligned}\]</p><p>with <span>$f: \mathbb{R}^n \to \mathbb{R}$</span> the objective function, <span>$g: \mathbb{R}^n \to \mathbb{R}^{m_E}$</span> non-linear equality constraints and <span>$h: \mathbb{R}^n \to \mathbb{R}^{m_I}$</span> non-linear inequality constraints.</p><h3 id="Callbacks"><a class="docs-heading-anchor" href="#Callbacks">Callbacks</a><a id="Callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Callbacks" title="Permalink"></a></h3><p>Most non-linear optimization algorithms rely on <em>callbacks</em> to pass information about the structure of the problem to the optimizer. In <code>Argos</code>, the implementation of the evaluators allows to have a proper splitting between the model (formulated in the <code>ExaPF.AbstractFormulation</code> layer) and the optimization algorithms. By design, the implementation of an <a href="../../lib/evaluators/#Argos.AbstractNLPEvaluator"><code>Argos.AbstractNLPEvaluator</code></a> shares a similar spirit with the implementations introduced in other packages, as</p><ul><li>MathOptInterface.jl&#39;s <a href="https://jump.dev/MathOptInterface.jl/stable/apireference/#MathOptInterface.AbstractNLPEvaluator">AbstractNLPEvaluator</a></li><li>NLPModels&#39; <a href="https://juliasmoothoptimizers.github.io/NLPModels.jl/stable/api/#AbstractNLPModel-functions">AbstractNLPModel</a></li></ul><p>Internally, the evaluator caches all the information needed to evaluate the callbacks (e.g. the polar representation of the problem, with voltage magnitudes and angles). This cache allows to reduce the number of memory allocations to its minimum. Once a new variable <span>$u$</span> passed to the evaluator a function <code>Argos.update!</code> is being called to update the cache, according to the model specified in the underlying <code>ExaPF.AbstractFormulation</code>. Denoting by <code>nlp</code> an instance of AbstractNLPEvaluator, the cache is updated via</p><pre><code class="language-julia-repl hljs">julia&gt; Argos.update!(nlp, u)</code></pre><p>Once the internal structure updated, we are ready to call the different callbacks, in every order. For instance, computing the objective, the gradient and the constraints amounts to</p><pre><code class="language-julia-repl hljs"># Objective
julia&gt; obj = Argos.objective(nlp, u)
# Gradient
julia&gt; g = zeros(n_variables(nlp))
julia&gt; Argos.gradient!(nlp, g, u)
# Constraints
julia&gt; cons = zeros(n_constraints(nlp))
julia&gt; Argos.constraint!(nlp, cons, u)
</code></pre><h2 id="A-journey-to-the-reduced-space-with-the-ReducedSpaceEvaluator"><a class="docs-heading-anchor" href="#A-journey-to-the-reduced-space-with-the-ReducedSpaceEvaluator">A journey to the reduced space with the ReducedSpaceEvaluator</a><a id="A-journey-to-the-reduced-space-with-the-ReducedSpaceEvaluator-1"></a><a class="docs-heading-anchor-permalink" href="#A-journey-to-the-reduced-space-with-the-ReducedSpaceEvaluator" title="Permalink"></a></h2><p>When we aim at optimizing the problem directly in the powerflow manifold, the <a href="../../lib/evaluators/#Argos.ReducedSpaceEvaluator"><code>Argos.ReducedSpaceEvaluator</code></a> is our workhorse. We recall that the powerflow manifold is defined implicitly by the powerflow equations:</p><p class="math-container">\[    g(x(u), u) = 0.\]</p><p>By design, the <a href="../../lib/evaluators/#Argos.ReducedSpaceEvaluator"><code>Argos.ReducedSpaceEvaluator</code></a> works in the reduced space <span>$(x(u), u)$</span>. Hence, the reduced optimization problem writes out</p><p class="math-container">\[\begin{aligned}
\min_{u \in \mathbb{R}^n} \; &amp; f(x(u), u) \\
\text{subject to} \quad      &amp; h(x(u), u) \leq 0.
\end{aligned}\]</p><p>This formulation comes with two advantages:</p><ul><li>if the dimension of the state is large, the reduced problem has a lower dimension.</li><li>the powerflow equality constraints <span>$g(x, u) = 0$</span> disappear in the reduced problem.</li></ul><h3 id="Playing-with-the-ReducedSpaceEvaluator"><a class="docs-heading-anchor" href="#Playing-with-the-ReducedSpaceEvaluator">Playing with the ReducedSpaceEvaluator</a><a id="Playing-with-the-ReducedSpaceEvaluator-1"></a><a class="docs-heading-anchor-permalink" href="#Playing-with-the-ReducedSpaceEvaluator" title="Permalink"></a></h3><h4 id="Constructor"><a class="docs-heading-anchor" href="#Constructor">Constructor</a><a id="Constructor-1"></a><a class="docs-heading-anchor-permalink" href="#Constructor" title="Permalink"></a></h4><p>To create a <a href="../../lib/evaluators/#Argos.ReducedSpaceEvaluator"><code>Argos.ReducedSpaceEvaluator</code></a>, we just need a polar formulation <code>polar::PolarForm</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; nlp = Argos.ReducedSpaceEvaluator(polar)
</code></pre><p>or we could alternatively instantiate the evaluator directly from a MATPOWER (or PSSE) instance:</p><pre><code class="language-julia-repl hljs">julia&gt; datafile = &quot;case9.m&quot;
julia&gt; nlp = Argos.ReducedSpaceEvaluator(datafile)
A ReducedSpaceEvaluator object
    * device: KernelAbstractions.CPU()
    * #vars: 5
    * #cons: 10
    * constraints:
        - voltage_magnitude_constraints
        - active_power_constraints
        - reactive_power_constraints
    * linear solver: ExaPF.LinearSolvers.DirectSolver()
</code></pre><p>Let&#39;s describe the output of the last command.</p><ul><li><code>device: KernelAbstractions.CPU()</code>: the evaluator is instantiated on the CPU ;</li><li><code>#vars: 5</code>: it has 5 optimization variables ;</li><li><code>#cons: 10</code>: and 10 inequality constraints ;</li><li><code>constraints</code>: by default, <code>nlp</code> comes with three inequality constraints: <code>voltage_magnitude_constraints</code> (specifying the bounds <span>$x_L \leq x(u) \leq x_U$</span> on the state <span>$x$</span>), <code>active_power_constraints</code> and <code>reactive_power_constraints</code> (bounding the active and reactive power of the generators) ;</li><li><code>linear solver</code>: <code>ExaPF.LinearSolvers.DirectSolver</code>: to solve the linear systems, the evaluator uses a direct linear algebra solver.</li></ul><p>Of course, these settings are only specified by default. The user is free to choose the parameters she wants. For instance,</p><ul><li>We could remove all constraints by passing an empty array of constraints to the evaluator:<pre><code class="language-julia-repl hljs">julia&gt; constraints = Function[]
julia&gt; nlp = Argos.ReducedSpaceEvaluator(datafile; constraints=constraints)</code></pre></li><li>We could load the evaluator on the GPU simply by changing the <code>device</code> option:<pre><code class="language-julia-repl hljs">julia&gt; nlp = Argos.ReducedSpaceEvaluator(datafile; device=CUDADevice())</code></pre></li></ul><h4 id="Caching"><a class="docs-heading-anchor" href="#Caching">Caching</a><a id="Caching-1"></a><a class="docs-heading-anchor-permalink" href="#Caching" title="Permalink"></a></h4><p>To juggle between the mathematical description (characterized by a state <span>$x$</span> and a control <span>$u$</span>) and the physical description (characterized by the voltage and power injection at each bus), the evaluator <code>nlp</code> stores internally a cache <code>nlp.buffer</code>, with type <code>ExaPF.AbstractNetworkBuffer</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; buffer = get(nlp, ExaPF.PhysicalState())</code></pre><h4 id="Evaluation-of-the-callbacks"><a class="docs-heading-anchor" href="#Evaluation-of-the-callbacks">Evaluation of the callbacks</a><a id="Evaluation-of-the-callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation-of-the-callbacks" title="Permalink"></a></h4><p>Now that we have a <code>nlp</code> evaluator available, we can embed it in any optimization routine. For instance, suppose we have a new control <code>uk</code> available. First, we need to find the corresponding state <code>xk</code>, such that <span>$g(x_k, u_k) = 0$</span>. In the evaluator&#39;s API, this sums up to:</p><pre><code class="language-julia-repl hljs">Argos.update!(nlp, uk)
</code></pre><p>The function <code>update!</code> will</p><ul><li>Feed the physical description <code>nlp.buffer</code> with the values stored in the new control <code>uk</code>.</li><li>Solve the powerflow equations corresponding to the formulation specified in <code>form</code>. This operation updates the cache <code>nlp.buffer</code> inplace.</li></ul><p>Once the function <code>update!</code> called (and only after that), we can evaluate all the different callbacks, independently of one other.</p><ul><li>Objective<pre><code class="language-julia-repl hljs">julia&gt; cost = Argos.objective(nlp, uk)</code></pre></li><li>Objective&#39;s gradient<pre><code class="language-julia-repl hljs">julia&gt; g = zeros(n_variables(nlp))
julia&gt; Argos.gradient!(nlp, g, uk)</code></pre></li><li>Constraints<pre><code class="language-julia-repl hljs"># Evaluate constraints
julia&gt; cons = zeros(n_constraints(nlp))
julia&gt; Argos.constraint!(nlp, cons, uk)</code></pre></li><li>Constraints&#39; Jacobian<pre><code class="language-julia-repl hljs">## Evaluate Jacobian
julia&gt; Argos.jacobian!(nlp, jac, uk)</code></pre></li><li>Constraints&#39; Jacobian-vector product:<pre><code class="language-julia-repl hljs">## Evaluate Jacobian-vector product
julia&gt; v = zeros(n_variables(nlp))
julia&gt; jv = zeros(n_constraints(nlp))
julia&gt; Argos.jprod!(nlp, jv, uk, v)</code></pre></li><li>Constraints&#39; transpose Jacobian-vector product<pre><code class="language-julia-repl hljs">## Evaluate transpose Jacobian-vector product
julia&gt; v = zeros(n_constraints(nlp))
julia&gt; jv = zeros(n_variables(nlp))
julia&gt; Argos.jtprod!(nlp, jv, uk, v)</code></pre></li><li>Hessian-vector product:<pre><code class="language-julia-repl hljs">## Evaluate transpose Jacobian-vector product
julia&gt; v = zeros(n_variables(nlp))
julia&gt; hv = zeros(n_variables(nlp))
julia&gt; Argos.hessprod!(nlp, hv, uk, v)</code></pre></li><li>Hessian:<pre><code class="language-julia-repl hljs">## Evaluate transpose Jacobian-vector product
julia&gt; H = zeros(n_variables(nlp), n_variables(nlp))
julia&gt; Argos.hessprod!(nlp, H, uk)</code></pre></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Once the powerflow equations solved in a <code>update!</code> call, the solution <span>$x_k$</span> is stored implicitly in <code>nlp.buffer</code>. These values will be used as a starting point for the next resolution of powerflow equations.</p></div></div><h2 id="Passing-the-problem-to-an-optimization-solver-with-MathOptInterface"><a class="docs-heading-anchor" href="#Passing-the-problem-to-an-optimization-solver-with-MathOptInterface">Passing the problem to an optimization solver with MathOptInterface</a><a id="Passing-the-problem-to-an-optimization-solver-with-MathOptInterface-1"></a><a class="docs-heading-anchor-permalink" href="#Passing-the-problem-to-an-optimization-solver-with-MathOptInterface" title="Permalink"></a></h2><p><code>Argos.jl</code> provides a utility to pass the non-linear structure specified by a <a href="../../lib/evaluators/#Argos.AbstractNLPEvaluator"><code>Argos.AbstractNLPEvaluator</code></a> to a <code>MathOptInterface</code> (MOI) optimization problem. That allows to solve the corresponding optimal power flow problem using any non-linear optimization solver compatible with MOI.</p><p>For instance, we can solve the reduced problem specified in <code>nlp</code> with Ipopt. In a few lines of code:</p><pre><code class="language-julia hljs">using Ipopt
optimizer = Ipopt.Optimizer()
MOI.set(optimizer, MOI.RawParameter(&quot;print_level&quot;), 5)
MOI.set(optimizer, MOI.RawParameter(&quot;limited_memory_max_history&quot;), 50)
MOI.set(optimizer, MOI.RawParameter(&quot;hessian_approximation&quot;), &quot;limited-memory&quot;)
solution = Argos.optimize!(optimizer, nlp)
MOI.empty!(optimizer)
</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../../lib/evaluators/">Evaluators »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 17 October 2022 22:10">Monday 17 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
