var documenterSearchIndex = {"docs":
[{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"CurrentModule = Argos","category":"page"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"using LazyArtifacts\nusing Argos, ExaPF\nusing SparseArrays\n\nartifact_toml = joinpath(@__DIR__, \"..\", \"..\", \"..\", \"Artifacts.toml\")\nexadata_hash = artifact_hash(\"ExaData\", artifact_toml)\nINSTANCES_DIR = joinpath(artifact_path(exadata_hash), \"ExaData\")\n","category":"page"},{"location":"man/fullspace/#FullSpaceEvaluator","page":"Full-space OPF","title":"FullSpaceEvaluator","text":"","category":"section"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"FullSpaceEvaluator models the original OPF problem in the full-space.","category":"page"},{"location":"man/fullspace/#Initialization","page":"Full-space OPF","title":"Initialization","text":"","category":"section"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"A FullSpaceEvaluator can be instantiated both from a MATPOWER file:","category":"page"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"datafile = joinpath(INSTANCES_DIR, \"case9.m\")\nflp = Argos.FullSpaceEvaluator(datafile)\n","category":"page"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"or equivalently, from a ExaPF.PolarForm object:","category":"page"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"polar = ExaPF.PolarForm(datafile)\nflp = Argos.FullSpaceEvaluator(polar)\n","category":"page"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"note: Note\nOne can remove the line-flow constraints in the model simply by adding the keyword argument flp = Argos.FullSpaceEvaluator(polar; line_constraints=false).","category":"page"},{"location":"man/fullspace/#Attributes","page":"Full-space OPF","title":"Attributes","text":"","category":"section"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"FullSpaceEvaluator is just a thin wrapper on top of ExaPF, and comes with just a few attributes. One can query the original ExaPF model with","category":"page"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"model = Argos.model(flp)\n","category":"page"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"The initial variable:","category":"page"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"x = Argos.initial(flp)","category":"page"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"The dimensions of the problem:","category":"page"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"(n, m) = Argos.n_variables(flp), Argos.n_constraints(flp)","category":"page"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"The bounds on the variables (x, u)","category":"page"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"xlb, xub = Argos.bounds(flp, Argos.Variables())\n[xlb xub]\n","category":"page"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"The bounds on the constraints:","category":"page"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"clb, cub = Argos.bounds(flp, Argos.Constraints())\n[clb cub]","category":"page"},{"location":"man/fullspace/#Sparse-Jacobian-and-sparse-Hessian","page":"Full-space OPF","title":"Sparse Jacobian and sparse Hessian","text":"","category":"section"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"More importantly, FullSpaceEvaluator stores two AD backends to evaluate the Jacobian and the Hessian in sparse format using ExaPF.","category":"page"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"For the Hessian, the AD backend is","category":"page"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"flp.hess\n","category":"page"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"generating the matrix","category":"page"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"flp.hess.H\n","category":"page"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"and for the Jacobian","category":"page"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"flp.jac\n","category":"page"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"generating the matrix","category":"page"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"flp.jac.J\n","category":"page"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"Both AD backends use coloring to reduce the number of Hessian-vector and Jacobian-vector products required to evaluate the Hessian and Jacobian in sparse format.","category":"page"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"To avoid dealing explicitly with the AD backends, Argos provides a function to query directly the Hessian and Jacobian in COO format:","category":"page"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"# Query sparsity pattern:\nj_I, j_J = Argos.jacobian_structure(flp)\nnnzj = length(j_I)\nj_V = zeros(nnzj)\nArgos.jacobian_coo!(flp, j_V, x)\nsparse(j_I, j_J, j_V) # build a SparseMatrixCSC","category":"page"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"and for the Hessian:","category":"page"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"# Query sparsity pattern:\nh_I, h_J = Argos.hessian_structure(flp)\nnnzh = length(h_I)\nh_V = zeros(nnzh)\ny = rand(m)\nArgos.hessian_lagrangian_coo!(flp, h_V, x, y, 1.0)\nsparse(h_I, h_J, h_V) # build a SparseMatrixCSC","category":"page"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"info: Info\nFor the Hessian, only the lower-triangular are being returned.","category":"page"},{"location":"man/fullspace/#Deport-on-CUDA-GPU","page":"Full-space OPF","title":"Deport on CUDA GPU","text":"","category":"section"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"Deporting all the operations on a CUDA GPU simply amounts to instantiating a FullSpaceEvaluator`](@ref) on the GPU, with","category":"page"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"using CUDAKernels # suppose CUDAKernels has been downloaded\nflp = Argos.FullSpaceEvaluator(datafile; device=CUDADevice())","category":"page"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"Then, the API remains exactly the same as on the CPU.","category":"page"},{"location":"man/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"When using device=CUDADevice(), the model is entirely instantiated on the device, without data left on the host (hence minimizing the communication costs). The computation of the derivatives is streamlined by propagating the tangents in parallel, leading to faster evaluations of the callbacks. As expected, the larger the model, the more significant the performance gain.","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Argos has lead to several publications in peer-reviewed journals.","category":"page"},{"location":"references/","page":"References","title":"References","text":"PP2022 details how Argos is evaluating the second-order reduced derivatives in parallel on the GPU. All results were generated with this artifact.","category":"page"},{"location":"references/","page":"References","title":"References","text":"PSCC2022 uses the augmented Lagrangian algorithm implemented in Argos to solve static and real-time OPF. All results were generated with this artifact.","category":"page"},{"location":"references/","page":"References","title":"References","text":"ARXIV2022 demonstrates the full capabilities of Argos to solve large-scale OPF on CUDA GPU, both in the full-space and in the reduced-space.","category":"page"},{"location":"quickstart/cpu/#Argos-on-CPU-(default)","page":"Argos on CPU (default)","title":"Argos on CPU (default)","text":"","category":"section"},{"location":"quickstart/cpu/","page":"Argos on CPU (default)","title":"Argos on CPU (default)","text":"using LazyArtifacts\n\nartifact_toml = joinpath(@__DIR__, \"..\", \"..\", \"..\", \"Artifacts.toml\")\nexadata_hash = artifact_hash(\"ExaData\", artifact_toml)\nINSTANCES_DIR = joinpath(artifact_path(exadata_hash), \"ExaData\")\n","category":"page"},{"location":"quickstart/cpu/","page":"Argos on CPU (default)","title":"Argos on CPU (default)","text":"Unless explicitly specified, Argos solves the OPF on the CPU. Argos provides 3 different methods to solve the OPF, all relying on the interior-point method (IPM).","category":"page"},{"location":"quickstart/cpu/","page":"Argos on CPU (default)","title":"Argos on CPU (default)","text":"","category":"page"},{"location":"quickstart/cpu/","page":"Argos on CPU (default)","title":"Argos on CPU (default)","text":"Method Derivatives KKT system\nFull-space Sparse Sparse\nBiegler Sparse Dense\nDommel & Tinney Dense Dense","category":"page"},{"location":"quickstart/cpu/","page":"Argos on CPU (default)","title":"Argos on CPU (default)","text":"","category":"page"},{"location":"quickstart/cpu/","page":"Argos on CPU (default)","title":"Argos on CPU (default)","text":"Full-space and Biegler are equivalent in exact arithmetic. Full-space solves the original (sparse) KKT system whereas Biegler uses a reduction method to find an equivalent (dense) linear system.\nDommel & Tinney is a port of the classical algorithm of Dommel and Tinney originally developed in 1968. It exploits the structure of the power flow equations to optimize only with relation to the degrees of freedom (the control, associated with the voltage at the PV nodes and the power generations). The reduction is the same as in Biegler, but Dommel & Tinney comprises an additional projection step to recover the dependent variables (the state). Currently, Dommel & Tinney uses the Newton-Raphson algorithm implemented in ExaPF to compute the projection step.","category":"page"},{"location":"quickstart/cpu/","page":"Argos on CPU (default)","title":"Argos on CPU (default)","text":"All three methods are described in detail in the Argos paper.","category":"page"},{"location":"quickstart/cpu/","page":"Argos on CPU (default)","title":"Argos on CPU (default)","text":"First, we set up the current Julia environment and choose an OPF instance in our artifact ExaData:","category":"page"},{"location":"quickstart/cpu/","page":"Argos on CPU (default)","title":"Argos on CPU (default)","text":"using Argos, MadNLP\ndatafile = joinpath(INSTANCES_DIR, \"case118.m\")\n","category":"page"},{"location":"quickstart/cpu/#Biegler's-method-(linearize-then-reduce)","page":"Argos on CPU (default)","title":"Biegler's method (linearize-then-reduce)","text":"","category":"section"},{"location":"quickstart/cpu/","page":"Argos on CPU (default)","title":"Argos on CPU (default)","text":"tip: Tip\nBiegler's reduction condenses and reduces the KKT linear system to a dense linear system whose size is given by the number of degrees of freedom in the problem. We recommend factorizing the resulting system with the Cholesky factorization shipped with Lapack.\nNote we obtain exactly the same convergence as with the previous FullSpace method, as the two methods are equivalent.","category":"page"},{"location":"quickstart/cpu/","page":"Argos on CPU (default)","title":"Argos on CPU (default)","text":"Argos.run_opf(datafile, Argos.BieglerReduction(); lapack_algorithm=MadNLP.CHOLESKY);\n","category":"page"},{"location":"quickstart/cpu/#Dommel-and-Tinney's-method-(reduce-then-linearize)","page":"Argos on CPU (default)","title":"Dommel & Tinney's method (reduce-then-linearize)","text":"","category":"section"},{"location":"quickstart/cpu/","page":"Argos on CPU (default)","title":"Argos on CPU (default)","text":"tip: Tip\nDommelTinney works in the reduced space, and the associated formulation has less variable than in the full space (107 versus 288).\nThe reduced Jacobian and reduced Hessian are dense, so DommelTinney can potentially eat a lot of memory on the largest instances.\nAs with BieglerReduction, we recommend using Lapack with a Cholesky factorization to solve the KKT system.\nNote that we have to increase MadNLP's tolerance (parameter tol) as we cannot optimize below the tolerance of the Newton-Raphson employed under the hood (1e-10 by default).","category":"page"},{"location":"quickstart/cpu/","page":"Argos on CPU (default)","title":"Argos on CPU (default)","text":"Argos.run_opf(datafile, Argos.DommelTinney(); tol=1e-5);\n","category":"page"},{"location":"lib/kkt/","page":"KKT systems","title":"KKT systems","text":"CurrentModule = Argos","category":"page"},{"location":"lib/kkt/#KKT-systems","page":"KKT systems","title":"KKT systems","text":"","category":"section"},{"location":"lib/kkt/","page":"KKT systems","title":"KKT systems","text":"Argos implements a MadNLP's KKT system MadNLP.AbstractKKTSystem whose operations can be deported on NVIDIA GPU.","category":"page"},{"location":"lib/kkt/","page":"KKT systems","title":"KKT systems","text":"BieglerKKTSystem","category":"page"},{"location":"lib/kkt/#Argos.BieglerKKTSystem","page":"KKT systems","title":"Argos.BieglerKKTSystem","text":"BieglerKKTSystem{T, VI, VT, MT, SMT} <: MadNLP.AbstractReducedKKTSystem{T, VT, MT}\n\nImplementation of Biegler's reduction method [BNS2015] in MadNLP's syntax. The API follows the MadNLP's specifications. The reduction is at the basis of the linearize-then-reduce method described in [PSSMA2022].\n\nReturn a dense matrix that can be factorized efficiently inside MadNLP by any dense linear algebra routine (e.g. Lapack).\n\nExamples\n\njulia> flp = Argos.FullSpaceEvaluator(\"case9.m\")\n\njulia> opf = Argos.OPFModel(flp)\n\njulia> T = Float64\n\njulia> VI, VT, MT = Vector{Int}, Vector{T}, Matrix{T}\n\njulia> kkt = Argos.BieglerKKTSystem{T, VI, VT, MT}(opf)\n\njulia> MadNLP.get_kkt(kkt) # return the matrix to factorize\n\n\nNotes\n\nBieglerKKTSystem can be instantiated both on the host memory (CPU) or on a NVIDIA GPU using CUDA. When instantiated on the GPU, BieglerKKTSystem uses cusolverRF to streamline the solution of the sparse linear systems in the reduction algorithm.\n\nReferences\n\n[BNS2015] Biegler, Lorenz T., Jorge Nocedal, and Claudia Schmid. \"A reduced Hessian method for large-scale constrained optimization.\" SIAM Journal on Optimization 5, no. 2 (1995): 314-347.\n\n[PSSMA2022] Pacaud, Fran√ßois, Sungho Shin, Michel Schanen, Daniel Adrian Maldonado, and Mihai Anitescu. \"Condensed interior-point methods: porting reduced-space approaches on GPU hardware.\" arXiv preprint arXiv:2203.11875 (2022).\n\n\n\n\n\n","category":"type"},{"location":"lib/wrappers/","page":"Wrappers","title":"Wrappers","text":"CurrentModule = Argos","category":"page"},{"location":"lib/wrappers/#Wrappers","page":"Wrappers","title":"Wrappers","text":"","category":"section"},{"location":"lib/wrappers/","page":"Wrappers","title":"Wrappers","text":"This page documents the API of the NLPModels and the MOI wrapper implemented in Argos.","category":"page"},{"location":"lib/wrappers/#NLPModels","page":"Wrappers","title":"NLPModels","text":"","category":"section"},{"location":"lib/wrappers/","page":"Wrappers","title":"Wrappers","text":"OPFModel\nbackend\n","category":"page"},{"location":"lib/wrappers/#Argos.OPFModel","page":"Wrappers","title":"Argos.OPFModel","text":"OPFModel <: NLPModels.AbstractNLPModel{Float64,Vector{Float64}}\n\nWrap a AbstractNLPEvaluator as a NLPModels.AbstractNLPModel.\n\nExamples\n\njulia> datafile = \"case9.m\"  # specify a path to a MATPOWER instance\n\njulia> nlp = Argos.ReducedSpaceEvaluator(datafile);\n\njulia> model = Argos.OPFModel(nlp)\n\n\nAttributes\n\nmeta::NLPModels.NLPModelMeta: information about the model.\ncounter::NLPModels.Counters: count how many time each callback is being called.\ntimer::NLPTimers: decompose time spent in each callback.\nnlp::AbstractNLPEvaluator: OPF model.\nhash_x::UInt: hash of the last evaluated variable x\nhrows::Vector{Int}: row indices of the Hessian.\nhcols::Vector{Int}: column indices of the Hessian.\njrows::Vector{Int}: row indices of the Jacobian.\njcols::Vector{Int}: column indices of the Jacobian.\netc::Dict{Symbol,Any}: a dictionnary for running experiments.\n\n\n\n\n\n","category":"type"},{"location":"lib/wrappers/#Argos.backend","page":"Wrappers","title":"Argos.backend","text":"Query the AbstractNLPEvaluator backend used inside the OPFModel m.\n\n\n\n\n\n","category":"function"},{"location":"lib/wrappers/#MOI-evaluator","page":"Wrappers","title":"MOI evaluator","text":"","category":"section"},{"location":"lib/wrappers/","page":"Wrappers","title":"Wrappers","text":"MOIEvaluator\n","category":"page"},{"location":"lib/wrappers/#Argos.MOIEvaluator","page":"Wrappers","title":"Argos.MOIEvaluator","text":"MOIEvaluator <: MOI.AbstractNLPEvaluator\n\nBridge from a AbstractNLPEvaluator to a MOI.AbstractNLPEvaluator.\n\nExample\n\njulia> datafile = \"case9.m\"  # specify a path to a MATPOWER instance\n\njulia> nlp = Argos.ReducedSpaceEvaluator(datafile);\n\njulia> ev = Argos.MOIEvaluator(nlp)\n\n\nAttributes\n\nnlp::AbstractNLPEvaluator: the underlying ExaPF problem.\nhash_x::UInt: hash of the last evaluated variable x\nhas_hess::Bool (default: false): if true, pass a Hessian structure to MOI.\n\n\n\n\n\n","category":"type"},{"location":"man/moi_wrapper/#MathOptInterface-wrapper","page":"MathOptInterface","title":"MathOptInterface wrapper","text":"","category":"section"},{"location":"man/moi_wrapper/","page":"MathOptInterface","title":"MathOptInterface","text":"using LazyArtifacts\n\nartifact_toml = joinpath(@__DIR__, \"..\", \"..\", \"..\", \"Artifacts.toml\")\nexadata_hash = artifact_hash(\"ExaData\", artifact_toml)\nINSTANCES_DIR = joinpath(artifact_path(exadata_hash), \"ExaData\")\n","category":"page"},{"location":"man/moi_wrapper/","page":"MathOptInterface","title":"MathOptInterface","text":"Argos.jl provides a utility to pass the nonlinear problem encoded by a Argos.AbstractNLPEvaluator to a MathOptInterface (MOI) optimization problem. Hence, we can solve the optimal power flow problem using any nonlinear optimization solver compatible with MOI (Ipopt, Knitro, ALGENCAN, ...).","category":"page"},{"location":"man/moi_wrapper/","page":"MathOptInterface","title":"MathOptInterface","text":"Once the MOI optimizer is set up properly, passing the optimizer to Argos simply amounts to calling the function Argos.optimize!. For example, solving an optimal power flow problem in the full-space amounts to:","category":"page"},{"location":"man/moi_wrapper/","page":"MathOptInterface","title":"MathOptInterface","text":"using MathOptInterface\nusing Argos, Ipopt\nconst MOI = MathOptInterface\n\n# Import data\ndatafile = joinpath(INSTANCES_DIR, \"case57.m\")\nflp = Argos.FullSpaceEvaluator(datafile)\n# Set-up MOI\noptimizer = Ipopt.Optimizer()\nMOI.set(optimizer, MOI.RawOptimizerAttribute(\"print_level\"), 5)\nMOI.set(optimizer, MOI.RawOptimizerAttribute(\"tol\"), 1e-5)\n# Solve\nsolution = Argos.optimize!(optimizer, flp)\nMOI.empty!(optimizer)\n","category":"page"},{"location":"optim/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"CurrentModule = Argos","category":"page"},{"location":"optim/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"using LazyArtifacts\nusing Argos, ExaPF\nusing SparseArrays\n\nartifact_toml = joinpath(@__DIR__, \"..\", \"..\", \"..\", \"Artifacts.toml\")\nexadata_hash = artifact_hash(\"ExaData\", artifact_toml)\nINSTANCES_DIR = joinpath(artifact_path(exadata_hash), \"ExaData\")\n","category":"page"},{"location":"optim/fullspace/#Full-space-OPF","page":"Full-space OPF","title":"Full-space OPF","text":"","category":"section"},{"location":"optim/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"Argos is tightly integrated with the nonlinear interior-point solver MadNLP. By default, Argos relies extensively on MadNLP to solve OPF problems, but other optimization solvers can be called using the NLPModels or the MOI interfaces.","category":"page"},{"location":"optim/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"We first detail how to solve the OPF in the full-space. We start by instantiating a FullSpaceEvaluator:","category":"page"},{"location":"optim/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"datafile = joinpath(INSTANCES_DIR, \"case9.m\")\nflp = Argos.FullSpaceEvaluator(datafile)\n","category":"page"},{"location":"optim/fullspace/#Instantiating-MadNLP","page":"Full-space OPF","title":"Instantiating MadNLP","text":"","category":"section"},{"location":"optim/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"By default, MadNLP is using NLPModels to represent the nonlinear model internally. Hence, one has to convert the FullSpaceEvaluator to an OPFModel:","category":"page"},{"location":"optim/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"model = Argos.OPFModel(flp)\n","category":"page"},{"location":"optim/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"Then, it remains to build a new MadNLPSolver instance attached to model:","category":"page"},{"location":"optim/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"using MadNLP\nsolver = MadNLP.MadNLPSolver(model)\n","category":"page"},{"location":"optim/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"It just remains to solve the OPF with MadNLP:","category":"page"},{"location":"optim/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"stats = MadNLP.solve!(solver)\n","category":"page"},{"location":"optim/fullspace/#Querying-the-solution","page":"Full-space OPF","title":"Querying the solution","text":"","category":"section"},{"location":"optim/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"MadNLP returns a MadNLPExecutionStats object storing the solution. One can query the optimal objective as:","category":"page"},{"location":"optim/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"stats.objective","category":"page"},{"location":"optim/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"and the optimal solution:","category":"page"},{"location":"optim/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"stats.solution","category":"page"},{"location":"optim/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"Also, remind that each time the callback update! is being called, the values are updated internally in the stack stored inside flp. Hence, an alternative way to query the solution is to directly have a look at the values in the stack. For instance, one can query the optimal values of the voltage","category":"page"},{"location":"optim/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"stack = flp.stack\n[stack.vmag stack.vang]","category":"page"},{"location":"optim/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"and of the power generation:","category":"page"},{"location":"optim/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"stack.pgen","category":"page"},{"location":"optim/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"info: Info\nThe values inside stack are used to compute the initial point in the optimization routine. Hence, if one calls solve! again the optimization would start from the optimal solution found in the previous call to solve!, leading to a different convergence pattern. If one wants to launch a new optimization from scratch without reinitializing all the data structure, we recommend using the reset! function:Argos.reset!(flp)","category":"page"},{"location":"optim/fullspace/#Playing-with-different-parameters","page":"Full-space OPF","title":"Playing with different parameters","text":"","category":"section"},{"location":"optim/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"MadNLP has different options we may want to tune when solving the OPF. For instance, we can loosen the tolerance to 1e-5 and set the maximum number of iterations to 5 with:","category":"page"},{"location":"optim/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"solver = MadNLP.MadNLPSolver(model; tol=1e-5, max_iter=5)\nMadNLP.solve!(solver)","category":"page"},{"location":"optim/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"Most importantly, one may want to use a different sparse linear solver than UMFPACK, employed by default in MadNLP. We recommend using HSL solvers (the installation procedure is detailed here). Once HSL is installed, one can solve the OPF with:","category":"page"},{"location":"optim/fullspace/","page":"Full-space OPF","title":"Full-space OPF","text":"using MadNLPHSL\nsolver = MadNLP.MadNLPSolver(model; linear_solver=Ma27Solver)\nMadNLP.solve!(solver)","category":"page"},{"location":"optim/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"CurrentModule = Argos","category":"page"},{"location":"optim/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"using LazyArtifacts\nusing Argos, ExaPF\nusing SparseArrays\n\nartifact_toml = joinpath(@__DIR__, \"..\", \"..\", \"..\", \"Artifacts.toml\")\nexadata_hash = artifact_hash(\"ExaData\", artifact_toml)\nINSTANCES_DIR = joinpath(artifact_path(exadata_hash), \"ExaData\")\n","category":"page"},{"location":"optim/reducedspace/#Reduced-space-OPF","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"","category":"section"},{"location":"optim/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"Solving the OPF in the reduced-space (aka reduce-then-linearize) follows the same procedure as in the full-space.","category":"page"},{"location":"optim/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"We start by instantiating a ReducedSpaceEvaluator:","category":"page"},{"location":"optim/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"datafile = joinpath(INSTANCES_DIR, \"case9.m\")\nred = Argos.ReducedSpaceEvaluator(datafile)\n","category":"page"},{"location":"optim/reducedspace/#Instantiating-MadNLP","page":"Reduced-space OPF","title":"Instantiating MadNLP","text":"","category":"section"},{"location":"optim/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"As before, we wrap the ReducedSpaceEvaluator object red with an OPFModel:","category":"page"},{"location":"optim/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"model = Argos.OPFModel(red)\n","category":"page"},{"location":"optim/reducedspace/#Why-we-should-not-use-MadNLP's-default-parameters?","page":"Reduced-space OPF","title":"Why we should not use MadNLP's default parameters?","text":"","category":"section"},{"location":"optim/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"Suppose now we instantiate a default MadNLP instance:","category":"page"},{"location":"optim/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"using MadNLP\nsolver = MadNLP.MadNLPSolver(model)\n","category":"page"},{"location":"optim/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"By default, MadNLP is using a sparse data structure. This is not appropriate to handle a ReducedSpaceEvaluator, which generates a dense Jacobian and a dense reduced Hessian. Indeed, by default MadNLP generates a sparse KKT system with a significant number of nonzeroes:","category":"page"},{"location":"optim/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"MadNLP.get_kkt(solver.kkt)\n","category":"page"},{"location":"optim/reducedspace/#How-to-parameterize-MadNLP-to-use-dense-data-structure?","page":"Reduced-space OPF","title":"How to parameterize MadNLP to use dense data structure?","text":"","category":"section"},{"location":"optim/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"Instead, we can parameterize MadNLP to use a dense KKT system. The first option is to use a DENSE_KKT_SYSTEM in conjunction with a dense linear solver (as Lapack):","category":"page"},{"location":"optim/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"solver = MadNLP.MadNLPSolver(\n    model;\n    kkt_system=MadNLP.DenseKKTSystem,\n    linear_solver=LapackCPUSolver,\n)\nMadNLP.get_kkt(solver.kkt)\n","category":"page"},{"location":"optim/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"The associated KKT system is now represented as a dense matrix, more appropriate for a dense problem. However, the generated KKT system is still too large, as its size is proportional to both the number of variables and the number of constraints. This approach is not tractable on larger problems. Fortunately, MadNLP allows to condense the KKT system using a Schur complement approach. By doing so, the size of the KKT system is only proportional to the number of variables (here, 5):","category":"page"},{"location":"optim/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"solver = MadNLP.MadNLPSolver(\n    model;\n    kkt_system=MadNLP.DenseCondensedKKTSystem,\n    linear_solver=LapackCPUSolver,\n)\nMadNLP.get_kkt(solver.kkt)\n","category":"page"},{"location":"optim/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"This alternative approach permits to significantly compress the size of the KKT system, and is the approach used by default in run_opf.","category":"page"},{"location":"optim/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"Once the problem is written in condensed form inside MadNLP, one can solve the OPF in the reduced-space with:","category":"page"},{"location":"optim/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"stats = MadNLP.solve!(solver; tol=1e-6)\n","category":"page"},{"location":"optim/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"info: Info\n","category":"page"},{"location":"optim/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"We recommend changing the default tolerance to be above the tolerance     of the Newton-Raphson used inside ReducedSpaceEvaluator. Indeed,     the power flow is solved only approximately, leading to slightly inaccurate     evaluations and derivatives, impacting the convergence of the interior-point     algorithm. In general, we recommend setting tol=1e-5.","category":"page"},{"location":"optim/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"info: Info\nHere, we are using Lapack on the CPU to solve the condensed KKT system at each iteration of the interior-point algorithm. However, if an NVIDIA GPU is available, we recommend using a CUDA-accelerated Lapack version, more efficient than the default Lapack. If MadNLPGPU is installed, this amounts tousing MadNLPGPU\nsolver = MadNLP.MadNLPSolver(\n    model;\n    kkt_system=MadNLP.DenseCondensedKKTSystem,\n    linear_solver=LapackGPUSolver,\n    tol=1e=5,\n)\nMadNLP.solve!(solver)","category":"page"},{"location":"optim/reducedspace/#Querying-the-solution","page":"Reduced-space OPF","title":"Querying the solution","text":"","category":"section"},{"location":"optim/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"As before, we can query the solution returned by MadNLP with:","category":"page"},{"location":"optim/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"stats.objective","category":"page"},{"location":"optim/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"and","category":"page"},{"location":"optim/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"stats.solution","category":"page"},{"location":"optim/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"Or, alternatively, one can look directly at the values in the stack stored inside red:","category":"page"},{"location":"optim/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"stack = red.stack\n[stack.vmag stack.vang]\n","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"CurrentModule = Argos","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"using LazyArtifacts\n\nartifact_toml = joinpath(@__DIR__, \"..\", \"..\", \"..\", \"Artifacts.toml\")\nexadata_hash = artifact_hash(\"ExaData\", artifact_toml)\nINSTANCES_DIR = joinpath(artifact_path(exadata_hash), \"ExaData\")\n","category":"page"},{"location":"man/overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"Argos acts as a layer built on top of ExaPF to formulate the OPF problem in a form suitable for optimization solvers (i.e. by formulating the problems with nonlinear callbacks). Depending on whether we are working in the full- or the reduced-space, the two principal evaluators are the FullSpaceEvaluator and the ReducedSpaceEvaluator.","category":"page"},{"location":"man/overview/#Abstraction","page":"Overview","title":"Abstraction","text":"","category":"section"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"Argos formulates the OPF problem in abstract form as","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"min_x u                f(x u)\nquad textsubject toquad\nleft\nbeginaligned\n  g(x u) = 0 \n                         h_l leq h(x u) leq h_u \nendaligned\nright","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"By design, the control variable u (voltage magnitude at PV and REF nodes, active power generations) is dissociated from the state variable x (voltage angle, voltage magnitudes at PQ nodes). The function f encodes the objective function, the function g is associated with the power flow equations](https://exanauts.github.io/ExaPF.jl/stable/lib/formulations/#ExaPF.PowerFlowBalance) and h encodes the remaining operational constraints (bounds on reactive power generations, line flow constraints).","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"note: Note\nCompared to MATPOWER or PowerModels, Argos comes with two major differences in the formulation.Only a subset of the power flow equations is considered, leading to a total of n_x instead of 2 n_bus equations.\nThe reactive power generations are considered only implicitly, through the remaining power flow equations.Hence, the problem formulated by Argos has a smaller size as the ones obtained through PowerModels or MATPOWER, at the expense of robustness.","category":"page"},{"location":"man/overview/#Usage","page":"Overview","title":"Usage","text":"","category":"section"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"For demonstration purposes, we instantiate a new FullSpaceEvaluator object associated with case9:","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"using ExaPF, Argos\ndatafile = joinpath(INSTANCES_DIR, \"case9.m\")\nflp = Argos.FullSpaceEvaluator(datafile)\n","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"We get the number of variables and constraints simply as","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"(n, m) = Argos.n_variables(flp), Argos.n_constraints(flp)\n","category":"page"},{"location":"man/overview/#Network-variables","page":"Overview","title":"Network variables","text":"","category":"section"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"Internally, each evaluator stores the current state of the network in a ExaPF.NetworkStack object. We can query the current state of the network as:","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"stack = flp.stack\n# Query current voltage magnitude and angle values\n[stack.vmag stack.vang]","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"The function update! updates the values in the cache:","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"x = rand(n)\nArgos.update!(flp, x)\n# The values in the cache are modified accordingly\n[stack.vmag stack.vang]\n","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"note: Note\nEvery time we have a new variable x, it is important to refresh the cache by calling explicitly Argos.update!(flp, x) before calling the other callbacks.","category":"page"},{"location":"man/overview/#Callbacks","page":"Overview","title":"Callbacks","text":"","category":"section"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"Now the cache has been refreshed by calling update!, one can query the different callbacks to evaluate the objective, the constraints and the derivatives:","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"Objective:","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"obj = Argos.objective(flp, x)","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"Gradient:","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"g = zeros(n)\nArgos.gradient!(flp, g, x)\ng","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"Constraints:","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"cons = zeros(m)\nArgos.constraint!(flp, cons, x)\ncons","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"note: Note\nAll the callbacks are written to modify the data (constraints, gradient) inplace, to avoid unneeded allocations. In addition, Argos.jl provides a version allocating automatically the return values:g = Argos.gradient(flp, x)\nc = Argos.constraint(flp, x)","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"Eventually, one can reset the evaluator to its original state by using reset!:","category":"page"},{"location":"man/overview/","page":"Overview","title":"Overview","text":"Argos.reset!(flp)\n[stack.vmag stack.vang]","category":"page"},{"location":"optim/biegler/","page":"Biegler's method","title":"Biegler's method","text":"CurrentModule = Argos","category":"page"},{"location":"optim/biegler/","page":"Biegler's method","title":"Biegler's method","text":"using LazyArtifacts\nusing Argos, ExaPF\nusing SparseArrays\n\nartifact_toml = joinpath(@__DIR__, \"..\", \"..\", \"..\", \"Artifacts.toml\")\nexadata_hash = artifact_hash(\"ExaData\", artifact_toml)\nINSTANCES_DIR = joinpath(artifact_path(exadata_hash), \"ExaData\")\n","category":"page"},{"location":"optim/biegler/#Biegler's-method","page":"Biegler's method","title":"Biegler's method","text":"","category":"section"},{"location":"optim/biegler/","page":"Biegler's method","title":"Biegler's method","text":"Solving the OPF in the reduced-space allows us to compress drastically the size of the OPF problem, but this comes with several downsides: (1) the power flow equations have to be solved at each iteration, (2) we have to evaluate explicitly the dense reduced Hessian and dense reduced Jacobian and (3) the solution is not so accurate (tolerance set to tol=1e-6) as the power flow equations are solved only approximately.","category":"page"},{"location":"optim/biegler/","page":"Biegler's method","title":"Biegler's method","text":"Alternatively, one can use Biegler's method, which reduces the KKT system directly in the full-space instead of working in the reduced-space. In exact arithmetic, this method is exactly equivalent to the full-space method, avoiding all the reduced-space machinery.","category":"page"},{"location":"optim/biegler/","page":"Biegler's method","title":"Biegler's method","text":"As this method is working in the full-space, we start by instantiating a new FullSpaceEvaluator:","category":"page"},{"location":"optim/biegler/","page":"Biegler's method","title":"Biegler's method","text":"datafile = joinpath(INSTANCES_DIR, \"case9.m\")\nflp = Argos.FullSpaceEvaluator(datafile)\n","category":"page"},{"location":"optim/biegler/","page":"Biegler's method","title":"Biegler's method","text":"and wrap the resulting evaluator flp in a OPFModel:","category":"page"},{"location":"optim/biegler/","page":"Biegler's method","title":"Biegler's method","text":"model = Argos.OPFModel(flp)\n","category":"page"},{"location":"optim/biegler/#Instantiating-MadNLP","page":"Biegler's method","title":"Instantiating MadNLP","text":"","category":"section"},{"location":"optim/biegler/","page":"Biegler's method","title":"Biegler's method","text":"Instantiating MadNLP manually to use a BieglerKKTSystem is a little bit more involved, as one has to parameterize the type directly, by defining:","category":"page"},{"location":"optim/biegler/","page":"Biegler's method","title":"Biegler's method","text":"KKT = Argos.BieglerKKTSystem{Float64, Vector{Int}, Vector{Float64}, Matrix{Float64}}","category":"page"},{"location":"optim/biegler/","page":"Biegler's method","title":"Biegler's method","text":"and we instantiate MadNLP with:","category":"page"},{"location":"optim/biegler/","page":"Biegler's method","title":"Biegler's method","text":"using MadNLP\n\nT = Float64\nVI = Vector{Int}\nVT = Vector{T}\nMT = Matrix{T}\nsolver = MadNLP.MadNLPSolver(\n    model;\n    kkt_system=Argos.BieglerKKTSystem{T, VI, VT, MT},\n    linear_solver=LapackCPUSolver,\n    callback=MadNLP.SparseCallback,\n)","category":"page"},{"location":"optim/biegler/","page":"Biegler's method","title":"Biegler's method","text":"Note that we are again using Lapack as linear solver: indeed the resulting Biegler's KKT system is dense (we use the same condensification procedure as in the reduced-space):","category":"page"},{"location":"optim/biegler/","page":"Biegler's method","title":"Biegler's method","text":"MadNLP.get_kkt(solver.kkt)","category":"page"},{"location":"optim/biegler/","page":"Biegler's method","title":"Biegler's method","text":"Once solver is instantiated, we can solve the OPF in the full-space using the same syntax as usual:","category":"page"},{"location":"optim/biegler/","page":"Biegler's method","title":"Biegler's method","text":"MadNLP.solve!(solver)","category":"page"},{"location":"optim/biegler/","page":"Biegler's method","title":"Biegler's method","text":"info: Info\nNote that we get the exact same convergence as in the full-space.","category":"page"},{"location":"man/nlpmodel_wrapper/","page":"NLPModels","title":"NLPModels","text":"CurrentModule = Argos","category":"page"},{"location":"man/nlpmodel_wrapper/#NLPModels","page":"NLPModels","title":"NLPModels","text":"","category":"section"},{"location":"man/nlpmodel_wrapper/","page":"NLPModels","title":"NLPModels","text":"using LazyArtifacts\n\nartifact_toml = joinpath(@__DIR__, \"..\", \"..\", \"..\", \"Artifacts.toml\")\nexadata_hash = artifact_hash(\"ExaData\", artifact_toml)\nINSTANCES_DIR = joinpath(artifact_path(exadata_hash), \"ExaData\")\n","category":"page"},{"location":"man/nlpmodel_wrapper/","page":"NLPModels","title":"NLPModels","text":"Knowledgeable users may have noticed that the Argos.AbstractNLPEvaluator API is closed to NLPModels. Hence, it is straightforward to wrap any AbstractNLPEvaluator in a NLPModels.AbstractNLPModel structure.","category":"page"},{"location":"man/nlpmodel_wrapper/#Initializing","page":"NLPModels","title":"Initializing","text":"","category":"section"},{"location":"man/nlpmodel_wrapper/","page":"NLPModels","title":"NLPModels","text":"In Argos, this is provided by the OPFModel structure, which takes as input any AbstractNLPEvaluator and converts it as an NLPModels.AbstractNLPModel`.","category":"page"},{"location":"man/nlpmodel_wrapper/","page":"NLPModels","title":"NLPModels","text":"using NLPModels\nusing Argos\n\n# Import OPF model in Argos\ndatafile = joinpath(INSTANCES_DIR, \"case57.m\")\nflp = Argos.FullSpaceEvaluator(datafile)\n\n# Convert it to a AbstractNLPModel:\nmodel = Argos.OPFModel(flp)\n@assert isa(model, NLPModels.AbstractNLPModel)\n","category":"page"},{"location":"man/nlpmodel_wrapper/#Playing-with-NLPModels'-API","page":"NLPModels","title":"Playing with NLPModels' API","text":"","category":"section"},{"location":"man/nlpmodel_wrapper/","page":"NLPModels","title":"NLPModels","text":"The user can use the standard NLPModels API to interact with the OPF model:","category":"page"},{"location":"man/nlpmodel_wrapper/","page":"NLPModels","title":"NLPModels","text":"Querying the number of variables:","category":"page"},{"location":"man/nlpmodel_wrapper/","page":"NLPModels","title":"NLPModels","text":"n = NLPModels.get_nvar(model)","category":"page"},{"location":"man/nlpmodel_wrapper/","page":"NLPModels","title":"NLPModels","text":"Querying the initial variable x0:","category":"page"},{"location":"man/nlpmodel_wrapper/","page":"NLPModels","title":"NLPModels","text":"x0 = NLPModels.get_x0(model)","category":"page"},{"location":"man/nlpmodel_wrapper/","page":"NLPModels","title":"NLPModels","text":"Evaluating the objective","category":"page"},{"location":"man/nlpmodel_wrapper/","page":"NLPModels","title":"NLPModels","text":"NLPModels.obj(model, x0)","category":"page"},{"location":"man/nlpmodel_wrapper/","page":"NLPModels","title":"NLPModels","text":"Evaluating the constraints","category":"page"},{"location":"man/nlpmodel_wrapper/","page":"NLPModels","title":"NLPModels","text":"NLPModels.cons(model, x0)","category":"page"},{"location":"man/nlpmodel_wrapper/","page":"NLPModels","title":"NLPModels","text":"Evaluating the gradient","category":"page"},{"location":"man/nlpmodel_wrapper/","page":"NLPModels","title":"NLPModels","text":"NLPModels.grad(model, x0)","category":"page"},{"location":"man/nlpmodel_wrapper/","page":"NLPModels","title":"NLPModels","text":"and so on...","category":"page"},{"location":"man/nlpmodel_wrapper/#Accelerating-the-callbacks-on-an-NVIDIA-GPU","page":"NLPModels","title":"Accelerating the callbacks on an NVIDIA GPU","text":"","category":"section"},{"location":"man/nlpmodel_wrapper/","page":"NLPModels","title":"NLPModels","text":"We can exploit any available NVIDIA GPU to accelerate the evaluation of the derivatives. To do so, one first needs to install ArgosCUDA](../quickstart/cuda.md).","category":"page"},{"location":"man/nlpmodel_wrapper/","page":"NLPModels","title":"NLPModels","text":"Then, we can instantiate a new evaluator on the GPU with:","category":"page"},{"location":"man/nlpmodel_wrapper/","page":"NLPModels","title":"NLPModels","text":"using ArgosCUDA, CUDAKernels\nflp = Argos.FullSpaceEvaluator(datafile; device=CUDADevice())\n","category":"page"},{"location":"man/nlpmodel_wrapper/","page":"NLPModels","title":"NLPModels","text":"The OPFModel structure works exclusively on the host memory, so we have to bridge the evaluator flp to the host before creating a new instance of OPFModel:","category":"page"},{"location":"man/nlpmodel_wrapper/","page":"NLPModels","title":"NLPModels","text":"brige = Argos.bridge(flp)\nmodel = Argos.OPFModel(bridge)\n","category":"page"},{"location":"man/nlpmodel_wrapper/","page":"NLPModels","title":"NLPModels","text":"note: Note\nBridging an evaluator between the host and the device induces significant data movements between the host and the device, as for each input or for each output we have to move the data back and forth between the host and the device. However, we have noticed that in practice the time to operate the data transfer is negligible compared to the other operations (linear algebra, KKT system solution) pursued inside the optimization algorithm.","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"CurrentModule = Argos","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"using LazyArtifacts\nusing Argos, ExaPF\nusing SparseArrays\n\nartifact_toml = joinpath(@__DIR__, \"..\", \"..\", \"..\", \"Artifacts.toml\")\nexadata_hash = artifact_hash(\"ExaData\", artifact_toml)\nINSTANCES_DIR = joinpath(artifact_path(exadata_hash), \"ExaData\")\n","category":"page"},{"location":"man/reducedspace/#ReducedSpaceEvaluator","page":"Reduced-space OPF","title":"ReducedSpaceEvaluator","text":"","category":"section"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"As opposed to the FullSpaceEvaluator, the ReducedSpaceEvaluator works in the reduced-space induced by the power flow equations. Numerically, this amounts to solving the system of nonlinear equations g(x u) =0 at each iteration, in order to find a state x(u) satisfying","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"g(x(u) u) = 0","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"In short, the reduced-space method satisfies automatically the power flow equations, at the price of solving a system of nonlinear equations at each iteration. The OPF problem reformulates in the reduced-space:","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"min_u                f(x(u) u)\nquad textsubject toquad\n                         h_l leq h(x(u) u) leq h_u ","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"The state x depends implicitly on the control u, and is removed from the optimization variables.","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"The associated reduced gradient and reduced Hessian can be evaluated using respectively the adjoint and the adjoint-adjoint methods, as described in this paper.","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"info: Info\nThe reduced-space method was one of the first method to solve the OPF, as described in the seminal article by Dommel & Tinney.","category":"page"},{"location":"man/reducedspace/#Initialization","page":"Reduced-space OPF","title":"Initialization","text":"","category":"section"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"A ReducedSpaceEvaluator can be instantiated both from a MATPOWER file:","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"datafile = joinpath(INSTANCES_DIR, \"case9.m\")\nred = Argos.ReducedSpaceEvaluator(datafile)\n","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"or equivalently, from a ExaPF.PolarForm object:","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"polar = ExaPF.PolarForm(datafile)\nred = Argos.ReducedSpaceEvaluator(polar)\n","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"The ReducedSpaceEvaluator is somewhat more complicated than the FullSpaceEvaluator, as it has to solve the power flow equations at each new evaluation. The full signature (with default arguments) is:","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"ReducedSpaceEvaluator(\n    model;                    # MATPOWER file or ExaPF.PolarForm object\n    line_constraints=true,\n    powerflow_solver=NewtonRaphson(1e-10),\n    linear_solver=nothing,\n    nbatch_hessian=1,\n)\n","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"In detail:","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"The argument line_constraints activates the line flows constraints in the model (by default true).\nThe option powerflow_solver allows passing a custom NewtonRaphson solver with different verbose level or stopping tolerance (by default the tolerance is set to 1e-10).\nThe option linear_solver specifies a custom linear solver to use in the Newton-Raphson algorithm and in the computation of the reduced derivatives. If set to nothing (default), Argos fallbacks to UMFPACK on the CPU, CUSOLVERRF on CUDA GPU. In addition, one can use any linear solver compatible with ExaPF, including iterative linear solvers.\nFinally, the argument nbatch_hessian specifies the number of right-hand-side used when solving a linear system A X = B in parallel (useful to streamline the evaluation of the reduced derivatives).","category":"page"},{"location":"man/reducedspace/#Attributes","page":"Reduced-space OPF","title":"Attributes","text":"","category":"section"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"Querying the attributes of a ReducedSpaceEvaluator works similarly to the FullSpaceEvaluator. One can query the original ExaPF model with","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"model = Argos.model(red)\n","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"The initial variable:","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"u = Argos.initial(red)","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"The dimensions of the problem:","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"(n, m) = Argos.n_variables(red), Argos.n_constraints(red)","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"The bounds on the control u","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"ulb, uub = Argos.bounds(red, Argos.Variables())\n[ulb uub]\n","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"The bounds on the constraints:","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"clb, cub = Argos.bounds(red, Argos.Constraints())\n[clb cub]","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"info: Info\nNote that the number of variables is n=5, compared to n=19 for the FullSpaceEvaluator: the state x has been removed from the formulation.","category":"page"},{"location":"man/reducedspace/#Reduced-callback","page":"Reduced-space OPF","title":"Reduced callback","text":"","category":"section"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"Let's have a look at the current cache:","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"stack = red.stack\n[stack.vmag stack.vang]","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"The voltages are those specified in the MATPOWER file case9.m.","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"Now comes the important part. When we call update! on a FullSpaceEvaluator, we just copy the values in x to the internal cache stack. The behavior is different for ReducedSpaceEvaluator: in addition to copying the values in u to the cache stack, we solve the power flow equations to find the associated implicit state x(u). This is illustrated by the following lines:","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"u .= 1.1\nArgos.update!(red, u)\n[stack.vmag stack.vang]","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"The values stored in u have been copied to the corresponding entries in stack (first three entries in stack.vmag, corresponding to the voltage magnitudes at the REF and the PV nodes). Then, the voltage magnitudes at the PQ nodes and the voltage angles have been updated implicitly so that the values stored in stack satisfy the power flow equations.","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"note: Note\nCalling update! on a ReducedSpaceEvaluator calls a power flow solver under the hood (which uses the Newton-Raphson algorithm implemented in ExaPF).","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"The nonlinear solver can be parameterized when instantiating a new ReducedSpaceEvaluator. For instance, if one wants to display the convergence of the Newton-Raphson algorithm (verbose=1) and loosen the tolerance in the stopping criterion (tol=1e-6), one can simply instantiate red as","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"red = Argos.ReducedSpaceEvaluator(\n    datafile;\n    powerflow_solver=NewtonRaphson(tol=1e-6, verbose=1)\n)","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"By calling update! again, we get:","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"Argos.update!(red, u)\n","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"with a slightly different solution (as we have loosened the tolerance):","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"stack = red.stack\n[stack.vmag stack.vang]","category":"page"},{"location":"man/reducedspace/#Reduced-gradient","page":"Reduced-space OPF","title":"Reduced gradient","text":"","category":"section"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"As for update!, evaluating the reduced gradient is slightly more involved in the reduced-space as it involves the solution of one (sparse) linear system involving the Jacobian of the power flow nabla_x g(x u). Putting aside this consideration, evaluating the gradient simply amounts to calling:","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"g = zeros(n)\nArgos.gradient!(red, g, u)\ng","category":"page"},{"location":"man/reducedspace/#Reduced-Jacobian-and-Hessian","page":"Reduced-space OPF","title":"Reduced Jacobian and Hessian","text":"","category":"section"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"Similarly, evaluating the reduced Jacobian and the reduced Hessian both involve resp. the solution of n_u and 2n_u linear equations.","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"Evaluating the (dense) reduced Jacobian translates to","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"J = zeros(m, n)\nArgos.jacobian!(red, J, u)\nJ\n","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"and similarly, for the (dense) reduced Hessian","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"H = zeros(n, n)\nArgos.hessian!(red, H, u)\nH\n","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"As we will explain later, the computation of the reduced Jacobian and reduced Hessian can be streamlined on the GPU.","category":"page"},{"location":"man/reducedspace/#Deport-on-CUDA-GPU","page":"Reduced-space OPF","title":"Deport on CUDA GPU","text":"","category":"section"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"Instantiating a ReducedSpaceEvaluator on an NVIDIA GPU translates to:","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"using CUDAKernels # suppose CUDAKernels has been downloaded\nred = Argos.ReducedSpaceEvaluator(datafile; device=CUDADevice(), nbatch_hessian=256)","category":"page"},{"location":"man/reducedspace/","page":"Reduced-space OPF","title":"Reduced-space OPF","text":"The number of batches nbatch_hessian is the number of right-hand sides used to streamline the solution of the linear systems.","category":"page"},{"location":"lib/api/","page":"Evaluators API","title":"Evaluators API","text":"CurrentModule = Argos","category":"page"},{"location":"lib/api/#Evaluator-API","page":"Evaluators API","title":"Evaluator API","text":"","category":"section"},{"location":"lib/api/#Description","page":"Evaluators API","title":"Description","text":"","category":"section"},{"location":"lib/api/","page":"Evaluators API","title":"Evaluators API","text":"AbstractNLPEvaluator","category":"page"},{"location":"lib/api/#Argos.AbstractNLPEvaluator","page":"Evaluators API","title":"Argos.AbstractNLPEvaluator","text":"AbstractNLPEvaluator\n\nAbstractNLPEvaluator implements the bridge between the problem formulation (see ExaPF.AbstractFormulation) and the optimization solver. Once the problem formulation bridged, the evaluator allows to evaluate:\n\nthe objective;\nthe gradient of the objective;\nthe constraints;\nthe Jacobian of the constraints;\nthe Jacobian-vector and transpose-Jacobian vector products of the constraints;\nthe Hessian of the objective;\nthe Hessian of the Lagrangian.\n\n\n\n\n\n","category":"type"},{"location":"lib/api/#API-Reference","page":"Evaluators API","title":"API Reference","text":"","category":"section"},{"location":"lib/api/#Optimization","page":"Evaluators API","title":"Optimization","text":"","category":"section"},{"location":"lib/api/","page":"Evaluators API","title":"Evaluators API","text":"optimize!","category":"page"},{"location":"lib/api/#Argos.optimize!","page":"Evaluators API","title":"Argos.optimize!","text":"optimize!(optimizer, nlp::AbstractNLPEvaluator, x0)\n\nUse optimization routine implemented in optimizer to optimize the optimal power flow problem specified in the evaluator nlp. Initial point is specified by x0.\n\nReturn the solution as a named tuple, with fields\n\nstatus::MOI.TerminationStatus: Solver's termination status, as specified by MOI\nminimum::Float64: final objective\nminimizer::AbstractVector: final solution vector, with same ordering as the Variables specified in nlp.\n\noptimize!(optimizer, nlp::AbstractNLPEvaluator)\n\nWrap previous optimize! function and pass as initial guess x0 the initial value specified when calling initial(nlp).\n\nExamples\n\nnlp = ExaPF.ReducedSpaceEvaluator(datafile)\noptimizer = Ipopt.Optimizer()\nsolution = ExaPF.optimize!(optimizer, nlp)\n\n\nNotes\n\nBy default, the optimization routine solves a minimization problem.\n\n\n\n\n\n","category":"function"},{"location":"lib/api/#Attributes","page":"Evaluators API","title":"Attributes","text":"","category":"section"},{"location":"lib/api/","page":"Evaluators API","title":"Evaluators API","text":"Variables\nConstraints\nn_variables\nn_constraints\nconstraints_type\n","category":"page"},{"location":"lib/api/#Argos.Variables","page":"Evaluators API","title":"Argos.Variables","text":"Variables <: AbstractNLPAttribute end\n\nAttribute corresponding to the optimization variables attached to a given AbstractNLPEvaluator.\n\n\n\n\n\n","category":"type"},{"location":"lib/api/#Argos.Constraints","page":"Evaluators API","title":"Argos.Constraints","text":"Constraints <: AbstractNLPAttribute end\n\nAttribute corresponding to the constraints  attached to a given AbstractNLPEvaluator.\n\n\n\n\n\n","category":"type"},{"location":"lib/api/#Argos.n_variables","page":"Evaluators API","title":"Argos.n_variables","text":"n_variables(nlp::AbstractNLPEvaluator)\n\nGet the number of variables in the problem.\n\n\n\n\n\n","category":"function"},{"location":"lib/api/#Argos.n_constraints","page":"Evaluators API","title":"Argos.n_constraints","text":"n_constraints(nlp::AbstractNLPEvaluator)\n\nGet the number of constraints in the problem.\n\n\n\n\n\n","category":"function"},{"location":"lib/api/#Argos.constraints_type","page":"Evaluators API","title":"Argos.constraints_type","text":"constraints_type(nlp::AbstractNLPEvaluator)\n\nReturn the type of the non-linear constraints of the evaluator nlp, as a Symbol. Result could be :inequality if problem has only inequality constraints, :equality if problem has only equality constraints, or :mixed if problem has both types of constraints.\n\n\n\n\n\n","category":"function"},{"location":"lib/api/#Callbacks","page":"Evaluators API","title":"Callbacks","text":"","category":"section"},{"location":"lib/api/","page":"Evaluators API","title":"Evaluators API","text":"update!\nobjective\ngradient!\nconstraint!\njacobian!\njacobian_coo!\njprod!\njtprod!\nojtprod!\nhessian!\nhessian_coo!\nhessprod!\nhessian_lagrangian_prod!\nhessian_lagrangian_penalty_prod!\n","category":"page"},{"location":"lib/api/#Argos.update!","page":"Evaluators API","title":"Argos.update!","text":"update!(nlp::AbstractNLPEvaluator, u::AbstractVector)\n\nUpdate the internal structure inside nlp with the new entry u. This method has to be called before calling any other callbacks.\n\n\n\n\n\n","category":"function"},{"location":"lib/api/#Argos.objective","page":"Evaluators API","title":"Argos.objective","text":"objective(nlp::AbstractNLPEvaluator, u)::Float64\n\nEvaluate the objective at given variable u.\n\n\n\n\n\n","category":"function"},{"location":"lib/api/#Argos.gradient!","page":"Evaluators API","title":"Argos.gradient!","text":"gradient!(nlp::AbstractNLPEvaluator, g, u)\n\nEvaluate the gradient of the objective, at given variable u. Store the result inplace in the vector g.\n\nNote\n\nThe vector g should have the same dimension as u.\n\n\n\n\n\n","category":"function"},{"location":"lib/api/#Argos.constraint!","page":"Evaluators API","title":"Argos.constraint!","text":"constraint!(nlp::AbstractNLPEvaluator, cons, u)\n\nEvaluate the constraints of the problem at given variable u. Store the result inplace, in the vector cons.\n\nNote\n\nThe vector cons should have the same dimension as the result returned by n_constraints(nlp).\n\n\n\n\n\n","category":"function"},{"location":"lib/api/#Argos.jacobian!","page":"Evaluators API","title":"Argos.jacobian!","text":"jacobian!(nlp::AbstractNLPEvaluator, jac::AbstractMatrix, u)\n\nEvaluate the Jacobian of the constraints, at variable u. Store the result inplace, in the m x n dense matrix jac.\n\n\n\n\n\n","category":"function"},{"location":"lib/api/#Argos.jacobian_coo!","page":"Evaluators API","title":"Argos.jacobian_coo!","text":"jacobian_coo!(nlp::AbstractNLPEvaluator, jac::AbstractVector, u)\n\nEvaluate the (sparse) Jacobian of the constraints at variable u in COO format. Store the result inplace, in the nnzj vector jac.\n\n\n\n\n\n","category":"function"},{"location":"lib/api/#Argos.jprod!","page":"Evaluators API","title":"Argos.jprod!","text":"jprod!(nlp::AbstractNLPEvaluator, jv, u, v)\n\nEvaluate the Jacobian-vector product J v of the constraints. The vector jv is modified inplace.\n\nLet (n, m) = n_variables(nlp), n_constraints(nlp).\n\nu is a vector with dimension n\nv is a vector with dimension n\njv is a vector with dimension m\n\n\n\n\n\n","category":"function"},{"location":"lib/api/#Argos.jtprod!","page":"Evaluators API","title":"Argos.jtprod!","text":"jtprod!(nlp::AbstractNLPEvaluator, jv, u, v)\n\nEvaluate the transpose Jacobian-vector product J^T v of the constraints. The vector jv is modified inplace.\n\nLet (n, m) = n_variables(nlp), n_constraints(nlp).\n\nu is a vector with dimension n\nv is a vector with dimension m\njv is a vector with dimension n\n\n\n\n\n\n","category":"function"},{"location":"lib/api/#Argos.ojtprod!","page":"Evaluators API","title":"Argos.ojtprod!","text":"ojtprod!(nlp::AbstractNLPEvaluator, jv, u, œÉ, v)\n\nEvaluate the transpose Jacobian-vector product J' * [œÉ ; v], with J the Jacobian of the vector [f(x); h(x)]. f(x) is the current objective and h(x) constraints. The vector jv is modified inplace.\n\nLet (n, m) = n_variables(nlp), n_constraints(nlp).\n\njv is a vector with dimension n\nu is a vector with dimension n\nœÉ is a scalar\nv is a vector with dimension m\n\n\n\n\n\n","category":"function"},{"location":"lib/api/#Argos.hessian!","page":"Evaluators API","title":"Argos.hessian!","text":"hessian!(nlp::AbstractNLPEvaluator, H, u)\n\nEvaluate the Hessian ‚àá¬≤f(u) of the objective function f(u). Store the result inplace, in the n x n dense matrix H.\n\n\n\n\n\n","category":"function"},{"location":"lib/api/#Argos.hessian_coo!","page":"Evaluators API","title":"Argos.hessian_coo!","text":"hessian_coo!(nlp::AbstractNLPEvaluator, hess::AbstractVector, u)\n\nEvaluate the (sparse) Hessian of the constraints at variable u in COO format. Store the result inplace, in the nnzh vector hess.\n\n\n\n\n\n","category":"function"},{"location":"lib/api/#Argos.hessprod!","page":"Evaluators API","title":"Argos.hessprod!","text":"hessprod!(nlp::AbstractNLPEvaluator, hessvec, u, v)\n\nEvaluate the Hessian-vector product ‚àá¬≤f(u) * v of the objective evaluated at variable u. Store the result inplace, in the vector hessvec.\n\nNote\n\nThe vector hessprod should have the same length as u.\n\n\n\n\n\n","category":"function"},{"location":"lib/api/#Argos.hessian_lagrangian_prod!","page":"Evaluators API","title":"Argos.hessian_lagrangian_prod!","text":"hessian_lagrangian_prod!(nlp::AbstractNLPEvaluator, hessvec, u, y, œÉ, v)\n\nEvaluate the Hessian-vector product of the Lagrangian function L(u y) = f(u) + sum_i y_i c_i(u) with a vector v:\n\n¬≤L(u y)  v  = œÉ ¬≤f(u)  v + sum_i y_i ¬≤c_i(u)  v\n\nStore the result inplace, in the vector hessvec.\n\nArguments\n\nhessvec is a AbstractVector with dimension n, which is modified inplace.\nu is a AbstractVector with dimension n, storing the current variable.\ny is a AbstractVector with dimension n, storing the current constraints' multipliers\nœÉ is a scalar, encoding the objective's scaling\nv is a vector with dimension n.\n\n\n\n\n\n","category":"function"},{"location":"lib/api/#Argos.hessian_lagrangian_penalty_prod!","page":"Evaluators API","title":"Argos.hessian_lagrangian_penalty_prod!","text":"hessian_lagrangian_penalty_prod!(nlp::AbstractNLPEvaluator, hessvec, u, y, œÉ, d, v)\n\nEvaluate the Hessian-vector product of the Augmented Lagrangian function L(u y) = f(u) + sum_i y_i c_i(u) + frac12 d_i c_i(u)^2 with a vector v:\n\n¬≤L(u y)  v  = œÉ ¬≤f(u)  v + sum_i (y_i + d_i) ¬≤c_i(u)  v + sum_i d_i c_i(u)^T c_i(u)\n\nStore the result inplace, in the vector hessvec.\n\nArguments\n\nhessvec is a AbstractVector with dimension n, which is modified inplace.\nu is a AbstractVector with dimension n, storing the current variable.\ny is a AbstractVector with dimension n, storing the current constraints' multipliers\nœÉ is a scalar\nv is a vector with dimension n.\nd is a vector with dimension m.\n\n\n\n\n\n","category":"function"},{"location":"lib/api/#Utilities","page":"Evaluators API","title":"Utilities","text":"","category":"section"},{"location":"lib/api/","page":"Evaluators API","title":"Evaluators API","text":"reset!","category":"page"},{"location":"lib/api/#Argos.reset!","page":"Evaluators API","title":"Argos.reset!","text":"reset!(nlp::AbstractNLPEvaluator)\n\nReset evaluator nlp to default configuration.\n\n\n\n\n\n","category":"function"},{"location":"#Argos","page":"Home","title":"Argos","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Argos.jl is a Julia package extending ExaPF.jl for the resolution of large-scale optimal power flow (OPF) problems on exascale architectures. Argos is built as a prototype to demonstrate the capability of GPU/SIMD hardware to accelerate the solution of large-scale OPF problems.","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Argos is a registered package and its installation amounts to:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add Argos","category":"page"},{"location":"","page":"Home","title":"Home","text":"The function run_opf takes as input a path to a regular MATPOWER file and solves the associated OPF problem:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Argos.run_opf(\"case9.m\", Argos.FullSpace())\n","category":"page"},{"location":"#Purpose","page":"Home","title":"Purpose","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When using the polar formulation, OPF problems translate to large-scale nonconvex nonlinear problems (NLP), challenging to solve. When solving such large-scale problems, the two bottlenecks are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"The evaluation of the nonlinear first- and second-order derivatives.\nThe solution of the Karush-Kuhn-Tucker (KKT) system inside the optimization solver.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The first point (1) is alleviated by using ExaPF.jl, a power-system modeler using automatic differentation (AD) to evaluate the derivatives efficiently in a vectorized fashion. Notably, ExaPF allows to deport the evaluation of the derivatives on CUDA GPUs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The second point (2) is usually solved by using efficient sparse linear solvers (e.g., Pardiso, HSL). Unfortunately, it is well-known that sparse linear solvers are difficult to port on GPU and SIMD architectures, as illustrated in this paper. As such, Argos is tightly integrated with the interior-point solver MadNLP.jl to exploit the structure of the optimal power flow problem in a condense and reduce approach.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Argos is a prototype, and is nowhere as mature as established packages such as MATPOWER or PowerModels.jl. However, Argos is building on the flexibility provided by the Julia language, and we believe it is a package well-suited for research purposes and advanced users.","category":"page"},{"location":"#Acknowledgments","page":"Home","title":"Acknowledgments","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Argos.jl development was supported by the Exascale Computing Project (ECP). The development of Argos has been greatly facilited by the flexibility offered by the Julia language and its excellent GPU ecosystem. Notably, Argos makes an extensive use of CUDA.jl and KernelAbstractions.jl. Argos is tightly integrated with the solver MadNLP, which was originally developed at Los Alamos National Laboratory.","category":"page"},{"location":"#Citing-Argos.jl","page":"Home","title":"Citing Argos.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use Argos.jl in your research, we would greatly appreciate you citing it.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{pacaud2022condensed,\n  title={Condensed interior-point methods: porting reduced-space approaches on GPU hardware},\n  author={Pacaud, Fran{\\c{c}}ois and Shin, Sungho and Schanen, Michel and Maldonado, Daniel Adrian and Anitescu, Mihai},\n  journal={arXiv preprint arXiv:2203.11875},\n  year={2022}\n}","category":"page"},{"location":"#Funding","page":"Home","title":"Funding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This research was supported by the Exascale Computing Project (17-SC-20-SC), a joint project of the U.S. Department of Energy‚Äôs Office of Science and National Nuclear Security Administration, responsible for delivering a capable exascale ecosystem, including software, applications, and hardware technology, to support the nation‚Äôs exascale computing imperative.","category":"page"},{"location":"#Table-of-contents","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"#Quickstart-2","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"quickstart/cpu.md\",\n    \"quickstart/cuda.md\",\n]\nDepth = 1","category":"page"},{"location":"#OPF-Model","page":"Home","title":"OPF Model","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"man/overview.md\",\n    \"man/fullspace.md\",\n    \"man/reducedspace.md\",\n]\nDepth = 1","category":"page"},{"location":"#OPF-Solution","page":"Home","title":"OPF Solution","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"optim/fullspace.md\",\n    \"optim/reducedspace.md\",\n    \"optim/biegler.md\",\n]\nDepth = 1","category":"page"},{"location":"#Wrappers","page":"Home","title":"Wrappers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"man/moi_wrapper.md\",\n    \"man/nlpmodel_wrapper.md\",\n]\nDepth = 1","category":"page"},{"location":"#Library","page":"Home","title":"Library","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"lib/api.md\",\n    \"lib/evaluators.md\",\n    \"lib/kkt.md\",\n    \"lib/wrappers.md\",\n]\nDepth = 1","category":"page"},{"location":"lib/evaluators/","page":"Evaluators Type","title":"Evaluators Type","text":"CurrentModule = Argos","category":"page"},{"location":"lib/evaluators/#Evaluators","page":"Evaluators Type","title":"Evaluators","text":"","category":"section"},{"location":"lib/evaluators/#FullSpaceEvaluator","page":"Evaluators Type","title":"FullSpaceEvaluator","text":"","category":"section"},{"location":"lib/evaluators/","page":"Evaluators Type","title":"Evaluators Type","text":"FullSpaceEvaluator","category":"page"},{"location":"lib/evaluators/#Argos.FullSpaceEvaluator","page":"Evaluators Type","title":"Argos.FullSpaceEvaluator","text":"FullSpaceEvaluator{T, VI, VT, MT} <: AbstractNLPEvaluator\n\nStructure to evaluate the optimal power flow problem in the full-space.\n\nWhen a new point x is passed to the evaluator, one has to refresh the internal stack by calling the function update!\n\nExamples\n\njulia> flp = Argos.FullSpaceEvaluator(ExaPF.load_polar(\"case9.m\"))\nA FullSpaceEvaluator object\n    * device: CPU()\n    * #vars: 19\n    * #cons: 36\n\njulia> x = Argos.initial(flp)\n19-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.63\n 0.85\n\njulia> Argos.update!(flp, x); # update values in stack\n\njulia> Argos.objective(flp, x) # get objective\n4509.0275\n\n\n\n\n\n","category":"type"},{"location":"lib/evaluators/#ReducedSpaceEvaluator","page":"Evaluators Type","title":"ReducedSpaceEvaluator","text":"","category":"section"},{"location":"lib/evaluators/","page":"Evaluators Type","title":"Evaluators Type","text":"ReducedSpaceEvaluator","category":"page"},{"location":"lib/evaluators/#Argos.ReducedSpaceEvaluator","page":"Evaluators Type","title":"Argos.ReducedSpaceEvaluator","text":"ReducedSpaceEvaluator{T, VI, VT, MT} <: AbstractNLPEvaluator\n\nReduced-space evaluator projecting the optimal power flow problem into the powerflow manifold defined by the nonlinear equation g(x u) = 0. The state x(u) is defined implicitly, as a function of the control u. Hence, the powerflow equation is implicitly satisfied when we are using this evaluator.\n\nOnce a new point u is passed to the evaluator, the user needs to call the method update! to find the corresponding state x(u) satisfying the balance equation g(x(u) u) = 0 and refresh the values in the internal stack.\n\nTaking as input an ExaPF.PolarForm structure, the reduced evaluator builds the bounds corresponding to the control u, The reduced evaluator could be instantiated on the host memory, or on a specific device (currently, only CUDA is supported).\n\nExamples\n\njulia> nlp = Argos.ReducedSpaceEvaluator(ExaPF.load_polar(\"case9.m\"))\nA ReducedSpaceEvaluator object\n    * device: CPU()\n    * #vars: 5\n    * #cons: 28\n    * linear solver: ExaPF.LinearSolvers.DirectSolver{SuiteSparse.UMFPACK.UmfpackLU{Float64, Int64}}\n\njulia> u = Argos.initial(nlp)\n5-element Vector{Float64}:\n 1.0\n 1.0\n 1.0\n 1.63\n 0.85\n\njulia> Argos.update!(nlp, u); # solve power-flow\n\njulia> obj = Argos.objective(nlp, u); # get objective\n\njulia> obj ‚âà 5438.323706\ntrue\n\n\nIf a GPU is available, we could instantiate nlp as\n\njulia> nlp_gpu = ReducedSpaceEvaluator(datafile; device=CUDADevice())\nA ReducedSpaceEvaluator object\n    * device: KernelAbstractions.CUDADevice()\n    * #vars: 5\n    * #cons: 10\n    * constraints:\n        - voltage_magnitude_constraints\n        - active_power_constraints\n        - reactive_power_constraints\n    * linear solver: ExaPF.LinearSolvers.DirectSolver()\n\n\nNote\n\nMathematically, we set apart the state x from the control u. In the implementation of ReducedSpaceEvaluator, we only deal with a control u and an attribute stack, storing all the physical values needed to describe the network. The attribute buffer stores the values of the control u and the state x Each time we are calling the method update!, the values of the control are copied into the buffer.\n\n\n\n\n\n","category":"type"},{"location":"lib/evaluators/#SlackEvaluator","page":"Evaluators Type","title":"SlackEvaluator","text":"","category":"section"},{"location":"lib/evaluators/","page":"Evaluators Type","title":"Evaluators Type","text":"SlackEvaluator","category":"page"},{"location":"lib/evaluators/#Argos.SlackEvaluator","page":"Evaluators Type","title":"Argos.SlackEvaluator","text":"SlackEvaluator{Evaluator<:AbstractNLPEvaluator, T, VT} <: AbstractNLPEvaluator\n\nReformulate a problem with inequality constraints as an equality constrained problem, by introducing a set of slack variables.\n\nDescription\n\nA SlackEvaluator takes as input an original AbstractNLPEvaluator, subject to inequality constraints\n\nbeginaligned\n       min_u in mathbbR^n quad  f(u)\nmathrmst quad  h^  h(u)  h^\n                     u^   u    u^\nendaligned\n\nThe SlackEvaluator instance rewrites this problem with inequalities as a new problem comprising only equality constraints, by introducing m slack variables s_1  s_m. The new problem writes out\n\nbeginaligned\n       min_u in mathbbR^n s in mathbbR^m quad  f(u)\n    mathrmst quad  h(u) - s = 0 \n                     u^   u    u^ \n                     h^   s    h^\nendaligned\n\nAttributes\n\ninner::Evaluator: original evaluator\ns_min::VT: stores lower bounds for slack variables\ns_max::VT: stores upper bounds for slack variables\nnv::Int: number of original variables\nns::Int: number of slack variables\n\n\n\n\n\n","category":"type"},{"location":"lib/evaluators/#AugLagEvaluator","page":"Evaluators Type","title":"AugLagEvaluator","text":"","category":"section"},{"location":"lib/evaluators/","page":"Evaluators Type","title":"Evaluators Type","text":"AugLagEvaluator","category":"page"},{"location":"lib/evaluators/#Argos.AugLagEvaluator","page":"Evaluators Type","title":"Argos.AugLagEvaluator","text":"AugLagEvaluator{Evaluator<:AbstractNLPEvaluator, T, VT} <: AbstractPenaltyEvaluator\n\nAugmented-Lagrangian evaluator.\n\nDescription\n\nTakes as input any AbstractNLPEvaluator encoding a non-linear problem\n\nbeginaligned\n       min_u quad  f(u)\nmathrmst quad  h^  h(u)  h^\n                     u^   u    u^\nendaligned\n\nand return a new evaluator reformulating the original problem by moving the m constraints h^  h(u)  h^ into the objective using a set of penalties œï_1  œï_m and multiplier estimates Œª_1  Œª_m:\n\nbeginaligned\n    min_u quad  f(u) + sum_i=1^m œï_i(h_i Œª_i)   \nmathrmst quad   u^   u     u^\nendaligned\n\nThis evaluator considers explicitly the inequality constraints, without reformulating them by introducing slack variables. Each penalty œï_i is defined as\n\nœï_i(h_i Œª_i) = Œª_i^ œÜ_i(h_i) + frac rho2  œÜ_i(h_i) _2^2\n\nwith œÜ_i a function to compute the current infeasibility\n\nœÜ_i(h_i Œª_i) = max0  Œª_i + œÅ (h_i - h_i^)    + min0  Œª_i + œÅ (h_i - h_i^)   \n\nAttributes\n\ninner::Evaluator: original problem.\ncons_type: type of the constraints of the original problem (equalities or inequalities).\ncons::VT: a buffer storing the current evaluation of the constraints for the inner evaluator.\nrho::T: current penalty.\nŒª::VT: current multiplier.\nscaler::MaxScaler{T,VT}: a scaler to rescale the range of the constraints in the original problem.\n\n\n\n\n\n","category":"type"},{"location":"lib/evaluators/#BridgeDeviceEvaluator","page":"Evaluators Type","title":"BridgeDeviceEvaluator","text":"","category":"section"},{"location":"lib/evaluators/","page":"Evaluators Type","title":"Evaluators Type","text":"BridgeDeviceEvaluator","category":"page"},{"location":"lib/evaluators/#Argos.BridgeDeviceEvaluator","page":"Evaluators Type","title":"Argos.BridgeDeviceEvaluator","text":"BridgeDeviceEvaluator{Evaluator, DVT, DMT} <: AbstractNLPEvaluator\n\nBridge an evaluator nlp instantiated on the device to use it on the host memory. The bridge evaluator moves the data between the host and device automatically.\n\nExample\n\n\njulia> polar = ExaPF.load_polar(\"case9.m\", CUDADevice())\n\n# Load an evaluator on a CUDA GPU\njulia> flp = Argos.FullSpaceEvaluator(polar)\n\njulia> bdg = Argos.bridge(flp)\n\njulia> x = Argos.initial(bdg)\n\njulia> @assert isa(x, Array) # x is defined on the host memory\n\njulia> Argos.objective(bdg, x) # evaluate the objective on the device\n\n\n\n\n\n\n","category":"type"},{"location":"quickstart/cuda/#Argos-on-NVIDIA-GPU","page":"Argos on NVIDIA GPU","title":"Argos on NVIDIA GPU","text":"","category":"section"},{"location":"quickstart/cuda/","page":"Argos on NVIDIA GPU","title":"Argos on NVIDIA GPU","text":"Argos has an extension to deport the solving of the OPF on CUDA GPU. This extension is currently unregistered and has to be installed manually. If you have Argos installed locally, one can install ArgosCUDA using Julia's package manager:","category":"page"},{"location":"quickstart/cuda/","page":"Argos on NVIDIA GPU","title":"Argos on NVIDIA GPU","text":"pkg> dev /path/to/Argos.jl/lib/ArgosCUDA.jl\n","category":"page"},{"location":"quickstart/cuda/","page":"Argos on NVIDIA GPU","title":"Argos on NVIDIA GPU","text":"Note that ArgosCUDA installs nontrivial dependencies, such as CUDA.jl. For that reason, the installation process takes an additional amount of time.","category":"page"},{"location":"quickstart/cuda/","page":"Argos on NVIDIA GPU","title":"Argos on NVIDIA GPU","text":"Then, once ArgosCUDA is installed, the procedure is the same as before.","category":"page"},{"location":"quickstart/cuda/","page":"Argos on NVIDIA GPU","title":"Argos on NVIDIA GPU","text":"using Argos, MadNLP\nusing ArgosCUDA, MadNLPGPU\ndatafile = joinpath(INSTANCES_DIR, \"case118.m\")\n","category":"page"},{"location":"quickstart/cuda/#Full-space-method","page":"Argos on NVIDIA GPU","title":"Full-space method","text":"","category":"section"},{"location":"quickstart/cuda/","page":"Argos on NVIDIA GPU","title":"Argos on NVIDIA GPU","text":"ArgosCUDA.run_opf_gpu(datafile, Argos.FullSpace())\n","category":"page"},{"location":"quickstart/cuda/#Biegler's-method-(linearize-then-reduce)","page":"Argos on NVIDIA GPU","title":"Biegler's method (linearize-then-reduce)","text":"","category":"section"},{"location":"quickstart/cuda/","page":"Argos on NVIDIA GPU","title":"Argos on NVIDIA GPU","text":"ArgosCUDA.run_opf_gpu(datafile, Argos.BieglerReduction(); linear_solver=LapackGPUSolver)\n","category":"page"},{"location":"quickstart/cuda/#Dommel-and-Tinney's-method-(reduce-then-linearize)","page":"Argos on NVIDIA GPU","title":"Dommel & Tinney's method (reduce-then-linearize)","text":"","category":"section"},{"location":"quickstart/cuda/","page":"Argos on NVIDIA GPU","title":"Argos on NVIDIA GPU","text":"ArgosCUDA.run_opf_gpu(datafile, Argos.DommelTinney(); linear_solver=LapackGPUSolver)\n","category":"page"}]
}
